---
title:  "`r metadata(sce)$param$name`"
author: "Functional Genomics Center Zurich"
output: 
  html_document:
    self_contained: false
    includes:
      in_header: fgcz_header.html
    css: fgcz.css
---

Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

```{r setup, include=FALSE}
require(SummarizedExperiment)
require(plotly)
require(scater)
require(ezRun)
require(DT)
require(htmltools)
require(dplyr)
require(Matrix) # sparse matrix
require(Seurat)

## ----------------------------------------------
## debug
# title:  "`r metadata(sce)$param$name`"
# sce <- readRDS("/export/local/scratch/gtan/dev/p2497-SCCountQC/20171222.A-SiCSeq_SCs_P5_SCCountQC/sce.rds")
# sce <- readRDS("/srv/gstore/projects/p2497/SCCountQC_27327_2018-06-17--00-09-24/20171222.A-SiCSeq_SCs_P5_SCCountQC/sce.rds")

param <- metadata(sce)$param

if(param$scProtocol == "10x"){
  rowData(sce) <- rename(data.frame(rowData(sce),
                                    check.names=FALSE, stringsAsFactors=FALSE),
                         gene_id=ID, gene_name=Symbol)
}

## ----------------------------------------------
## scater sce
param$minReadsPerCell = 1e4
param$minReadsPerGene = 5
# param$minGenesDetected = 400 ## we should also filter genes that do not have param$minReadsPerGene for at least param$minGenesDetected

sceScater <- sce[ , Matrix::colSums(assays(sce)$counts) >= param$minReadsPerCell]

mito <- rownames(sceScater)[grepl("^mt-", rowData(sceScater)$gene_name)]
x <- assays(sceScater)$counts
cell_info <- data.frame(row.names = colnames(x),
                        lib_size=Matrix::colSums(x)/1e6, 
                        expr_genes = Matrix::colSums(x>0), 
                        perc_mito=Matrix::colSums(x[mito,])*100/Matrix::colSums(x))

## sceFixName for section "Reads on top 50 genes" and "Expression metrics"
sceFixName <- sceScater
rownames(sceFixName) <- make.unique(rowData(sceFixName)$gene_name)
is.mito <- grepl("^mt-", rownames(sceFixName))
sceFixName <- calculateQCMetrics(sceFixName, feature_controls=list(Mt=is.mito))
if(param$scProtocol == "smart-Seq2"){
  libsize.drop <- isOutlier(sceFixName$total_counts, nmads=5, type="lower",
                            log=TRUE)
  feature.drop <- isOutlier(sceFixName$total_features, nmads=5, type="lower",
                            log=TRUE)
  sceFixName <- sceFixName[,!(libsize.drop | feature.drop )]
}

## ----------------------------------------------
## datasetAllCells for section "Heatmap of reads per cell on the plate"
if(param$scProtocol == "smart-Seq2"){
  datasetAllCells <- data.frame(colData(sce),
                                check.names = FALSE, stringsAsFactors=FALSE)
}

## ----------------------------------------------
## picard metrics
if(param$scProtocol == "smart-Seq2"){
  evalPicard <- TRUE
}else if(param$scProtocol == "10x"){
  evalPicard <- FALSE
}

## ----------------------------------------------
## SeuratObject fro Seurat section
sceSeurat <- sce
rownames(sceSeurat) <- make.unique(rowData(sceSeurat)$gene_name)
countsSeurat <- assays(sceSeurat)$counts
if(param$scProtocol == "smart-Seq2"){
  countsSeurat <- countsSeurat[ ,Matrix::colSums(countsSeurat) > param$min_counts]
}

scData <- CreateSeuratObject(raw.data = countsSeurat, min.cells = 5,
                             project = param$name)
mito.genes <- grep(pattern = "^mt-", x = rownames(x = scData@data),
                   value = TRUE)
percent.mito <- Matrix::colSums(scData@raw.data[mito.genes, ])/ Matrix::colSums(scData@raw.data)
scData <- AddMetaData(object = scData, metadata = percent.mito, 
                      col.name = "percent.mito")
if(param$scProtocol == "smart-Seq2"){
  scalingFactorSeurat <- 1e5
}else if(param$scProtocol == "10x"){
  scalingFactorSeurat <- 1e4
}
```

## CountQC_Result {.tabset}

### Overview

* **Total Number of Cells:** `r ncol(sce)`
<!-- * **Number of cells removed:**  `r ncol(sce)-ncol(sceScater)` -->
<!--   + cells with less than `r param$minReadsPerCell` reads aligned  -->
<!--   + cells with less than `r param$minGenesDetected` genes that have at least `r param$minReadsPerGene` reads -->
<!-- * **Cells used:** `r ncol(sce)` -->
* **Median Genes per Cell** = `r median(cell_info$expr_genes)`
* **Median Reads per Cell** = `r round(median(cell_info$lib_size*1e6),0)`
* Number of input reads = `r ifelse(is.null(metadata(sce)$mlog), NA, metadata(sce)$mlog["Number of input reads",2])`
* % of reads mapped to multiple loci = `r ifelse(is.null(metadata(sce)$mlog), NA, metadata(sce)$mlog["% of reads mapped to multiple loci",2])`

### #Genes detected in cells

Interactive plot showing the read counts vs the number of expressed genes for all cells. Each dot is a cell.

```{r genes detected in cells, fig.width=8, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
xax <- list(
  title = "Read counts (million)",
  zeroline = FALSE
)
yax <- list(
  title = "Number of expressed genes",
  zeroline = FALSE
)
plot_ly(data=cell_info, x=~lib_size, y=~expr_genes, 
        text=rownames(cell_info),
        marker = list(color="deepskyblue3"), type='scatter') %>% 
  layout(xaxis = xax, yaxis = yax)
```

### QC metrics on the cells

Histograms of read counts, number of expressed genes and proportion of reads assigned to mitochondrial genes for all cells

```{r QC metrics on the cells, fig.width=10, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
yax <- list(
  title = "Number of cells"
)
p1 <- plot_ly(data=cell_info, x=~lib_size) %>%
  layout(xaxis = list(title="Read counts (million)"), yaxis = yax)
p2 <- plot_ly(data=cell_info, x=~expr_genes) %>%
  layout(xaxis = list(title="Number of expressed genes"), yaxis = yax)
p3 <- plot_ly(data=cell_info, x=~perc_mito) %>%
  layout(xaxis = list(title="Mitochondrial proportion (%)"), yaxis = yax)
subplot(p1, p2, p3, titleX=TRUE, titleY=TRUE, nrows=1) %>%
  layout(showlegend = FALSE)
```

### Reads on top 50 genes

Percentage of total counts assigned to the top 50 most highly-abundant genes. For each gene, each bar represents the percentage assigned to that gene for a single cell, while the circle represents the average across all cells.

```{r top 50 genes, fig.width=6, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "highest-expression", n=50)
```

### Expression metrics

Number of cells with expression for a gene against mean expression level.

```{r expression metrics, fig.width=8, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "exprs-freq-vs-mean")
```

### Heatmap of reads per cell on the plate

Sequenced reads on the plate layout.The heatmap values are in $log10$ scale.
The colorScale ranges from half of median value to twice of median value.

This is only available for plate based single cell protocol.

```{r plate layout, echo=FALSE, message=FALSE, warning=FALSE, eval=param$scProtocol=="smart-Seq2"}
plateMatrix <- plateStatistics(datasetAllCells)

if(!is.na(plateMatrix)){
  plateMatrix$`user ready made`$`LibConc_100_800bp [Characteristic]`=NULL
  l <- htmltools::tagList()
  ## This is the way of plotting plotly figures within a loop in knitr code chunk
  for(plateName in names(plateMatrix)){
    for(colname in names(plateMatrix[[plateName]])){
      p <- heatmapPlate(plateMatrix[[plateName]][[colname]],
                        title=paste(plateName, colname, sep=": "),
                        center=TRUE, log10=TRUE,
                        width = 500*(1 + sqrt(5))/2, height = 500)
      ## tagList ignores chunk optiosn for figrue size.
      ## control the size in plotly.
      l[[paste(plateName, colname, sep=": ")]] <- as_widget(p)
    }
  }
  l
}
```


### Gene Detection Rates

This is only available for full length single cell protocol.

```{r gene detection rates, fig.width=8, fig.height=8, echo=FALSE, message=FALSE, warning=FALSE, eval=evalPicard}
scePC = sce
scePC = scePC[rowData(scePC)$biotypes == "protein_coding", ]
widthOffset = 200
logWidthBreaks = c(9.5, 10.5, 11.5)
gcBreaks = c(0.42, 0.48, 0.53, 0.57, 0.62)
refWidthBin = "(9.5 - 10.5]" 
refGcBin = "(0.53 - 0.57]"
  ## define the gene strata
logWidth = log2(rowData(scePC)$featWidth + widthOffset)
lwClasses = ezCut(logWidth, breaks = logWidthBreaks)
gcClasses = ezCut(rowData(scePC)$gc, gcBreaks)
geneBins = tapply((1:nrow(scePC)), list(logWidth=lwClasses, gc=gcClasses), identity)

fracPresentByGene = Matrix::rowMeans(assays(scePC)$counts > param$minReadsPerGene)
fracPresentBinned = ezMatrix(0, rows=rownames(geneBins), cols=colnames(geneBins))
for (i in 1:length(geneBins)){
  fracPresentBinned[i] = mean(fracPresentByGene[geneBins[[i]]])
}

ezHeatmap(fracPresentBinned[nrow(fracPresentBinned):1, ], lim=c(0, 0.2),
          Rowv = FALSE, Colv = FALSE, main="", colors=gray((1:256)/256),
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="",
          xlab="GC", ylab="log2 gene length", margins=c(8,8))


ezHeatmap(log2((fracPresentBinned[nrow(fracPresentBinned):1, ] + 1e-3) / 
                 fracPresentBinned[refWidthBin, refGcBin]), lim=c(-2, 2),
          Rowv = FALSE, Colv = FALSE, main="",
          colors=getBlueRedScale(),
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="",
          xlab="GC", ylab="log2 gene length", margins=c(8,8))

binCombs = expand.grid(logWidth=rownames(geneBins), gc=colnames(geneBins))
gcWidthScores = ezMatrix(NA, rows=paste(binCombs$logWidth, binCombs$gc), 
                         cols=colnames(scePC))
for (i in 1:nrow(binCombs)){
  idx = geneBins[[binCombs$logWidth[i], binCombs$gc[i]]]
  gcWidthScores[paste(binCombs$logWidth[i], binCombs$gc[i]), ] = Matrix::colMeans(assays(scePC)$counts[idx, , drop=FALSE] > param$minReadsPerGene)
}

gcWidthScoresRel = log2((gcWidthScores + 0.01) / Matrix::rowMeans(gcWidthScores))

ezHeatmap(gcWidthScores[ ,order(Matrix::colSums(assays(scePC)$counts) > 3)], lim=c(0, 0.2), Rowv = FALSE, Colv = FALSE, main="", colors=gray((1:256)/256), labCol="",
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="", xlab="cells", ylab="bins", margins=c(8,8))


ezHeatmap(gcWidthScoresRel[ ,order(Matrix::colSums(assays(scePC)$counts > 3))], lim=c(-2, 2), Rowv = TRUE, Colv = FALSE, main="", colors=getBlueRedScale(), labCol = "",
          cexRow=1, cexCol=1, key.xlab="detection bias", key.title="", xlab="cells", ylab="bins", margins=c(8,16))

```

### Picard Metrics
A overview of scRNA-Seq QC metrics from Picard over the plate. 
For the detais of the metrics, please refer to 
https://broadinstitute.github.io/picard/picard-metric-definitions.html

This is only available for plate based single cell protocol.

```{r picard setup, echo=FALSE, eval=evalPicard}
cd <- data.frame(colData(sce), check.names = FALSE)
cd$nGenesDetected <- Matrix::colSums(assays(sce)$counts > 3)
```

```{r picard plot, echo=FALSE, fig.width=20, fig.height=6, eval=evalPicard}
plateMatrix <- plateStatistics(cd, 
                               colname=c("PF_READS", "nGenesDetected",
                                         "PCT_RIBOSOMAL_BASES", "PF_READS_ALIGNED",
                                         "PF_MISMATCH_RATE", "PCT_ADAPTER",
                                         "PCT_MRNA_BASES", "MEDIAN_CV_COVERAGE",
                                         "MEDIAN_5PRIME_BIAS", "MEDIAN_3PRIME_BIAS",
                                         "PERCENT_DUPLICATION"))
metricsNonLog <- c("PF_MISMATCH_RATE", "PCT_ADAPTER", "MEDIAN_5PRIME_BIAS",
                   "MEDIAN_3PRIME_BIAS", "PERCENT_DUPLICATION")
plateName <- names(plateMatrix)[1]
l <- htmltools::tagList()
for(plateName in names(plateMatrix)){
  for(colname in setdiff(names(plateMatrix[[plateName]]), 
                         c("PF_READS", "nGenesDetected"))){
    matrix2PlotOrigin <- matrix2Plot <- plateMatrix[[plateName]][[colname]]
    if(colname %in% metricsNonLog){
      ## non-log scale
      med_matrix2Plot <- median(matrix2Plot, na.rm=TRUE)
      range_colour <- sort(c(0, 2*med_matrix2Plot)) ## in case for negative values
      p1 <- heatmapPlate(matrix2PlotOrigin, log10 = FALSE, center = TRUE,
                         title=paste(plateName, colname, sep=": "),
                         colors="RdYlGn")
    }else{
      ## log-scale
      stopifnot(all(matrix2Plot >= 0)) ## It has to be positive to log
      matrix2Plot[matrix2Plot==0] <- min(0.25 * matrix2Plot[matrix2Plot >0],
                                         na.rm = TRUE)
      matrix2Plot <- log10(matrix2Plot)
      med_matrix2Plot <- median(matrix2Plot, na.rm=TRUE)
      range_colour <- c(med_matrix2Plot-log10(2), med_matrix2Plot+log10(2))
      p1 <- heatmapPlate(matrix2PlotOrigin, log10=TRUE, center = TRUE,
                       title=paste(plateName, colname, sep=": "), 
                       colors="RdYlGn")
    }
    
    ## To make the scatter plot have the same colourscale as heatmap
    ## There are two options:
    ## 1. fake the data into cd2 with minimal and maximal colourrange.
    ##    Certainly it's not elegent.
    # cd2 <- data.frame(PF_READS=c(-1, -1, c(plateMatrix[[plateName]]$PF_READS)),
    #                   nGenesDetected=c(-1,-1, c(plateMatrix[[plateName]]$nGenesDetected)),
    #                   metric=c(range_colour, c(matrix2Plot)),
    #                   metricOriginal=c(range_colour, c(plateMatrix[[plateName]][[colname]]))
    #                   )
    ## color by metric, plot value by metricOriginal
    ## 2. use the cmin and cmax in scatter plot. The colour of points is right,
    ##   but the color bar is wrong.
    ##   Anyway we only use the color bar from heatmap.
    ## I use option 2.
    cd2 <- data.frame(PF_READS=c(plateMatrix[[plateName]]$PF_READS),
                      nGenesDetected=c(plateMatrix[[plateName]]$nGenesDetected),
                      matrix2Plot=c(matrix2Plot),
                      matrix2PlotOrigin=c(matrix2PlotOrigin),
                      position=apply(expand.grid(rownames(matrix2PlotOrigin),
                                                 colnames(matrix2PlotOrigin)), 
                                     1, paste, collapse=": ")
                      )
    if(colname == "PF_READS_ALIGNED"){
      cd2 <- transform(cd2, matrix2PlotOrigin=matrix2PlotOrigin/PF_READS)
    }
    p2 <- plot_ly(data = cd2, x = ~PF_READS, y = ~nGenesDetected,
                    color = ~matrix2Plot, text=~position,
                    type="scatter", mode = 'markers', colors="RdYlGn",
                    marker=list(cmin=range_colour[1], cmax=range_colour[2])) %>%
            hide_colorbar() 
    p3 <- plot_ly(data = cd2, x = ~PF_READS, y = ~matrix2PlotOrigin,
                  color = ~matrix2Plot, text=~position,
                  type="scatter", mode = 'markers', colors="RdYlGn",
                  marker=list(cmin=range_colour[1], cmax=range_colour[2])) %>%
            hide_colorbar()
    p2 <- p2 %>%
              layout(xaxis=list(type="log"),
                     yaxis=list(type="log", title="# of Genes Detected"))
    if(colname %in% metricsNonLog){
      p3 <- p3 %>%
              layout(xaxis=list(type="log"), yaxis=list(title=colname))
    }else{
      p3 <- p3 %>%
            layout(xaxis=list(type="log"),
                   yaxis=list(type="log", title=colname))
    }
    l[[paste(plateName, colname, sep=": ")]] <- 
      as_widget(subplot(p1, p2, p3, nrows=1, titleX=TRUE, titleY=TRUE) %>%
                    layout(showlegend = FALSE))
  }
}
l
```

### Picard Metrics Summary

This is only available for plate based single cell protocol.

```{r metrics, echo=FALSE, eval=evalPicard}
metricsDT <- colData(sce)[, (tail(grep("\\[File\\]", colnames(colData(sce))), 1)+1):ncol(colData(sce))]
datatable(data.frame(metricsDT, check.names = FALSE), filter = 'top',
          caption="scRNASeq QC Metrics")
```

```{r 5 prime bias, echo=FALSE, eval=FALSE}
x <- list(
  title = "Prime bias"
)

p <- plot_ly(alpha = 0.6) %>%
  add_histogram(x = ~colData(sce)$`bias5`, name="5 prime bias") %>%
  add_histogram(x = ~colData(sce)$`bias3`, name="3 prime bias") %>%
  layout(barmode = "overlay", title="Mean prime bias",
         xaxis=x)

p

p2 <- plot_ly(alpha = 0.6) %>%
  add_histogram(x = ~colData(sce)$`MEDIAN_5PRIME_BIAS`, name="5 prime bias") %>%
  add_histogram(x = ~colData(sce)$`MEDIAN_3PRIME_BIAS`, name="3 prime bias") %>%
  layout(barmode = "overlay", title="Median prime bias: Picard",
         xaxis=x)
p2
```

### Seurat

```{r VlnPlot, echo=FALSE}
VlnPlot(object = scData, features.plot = c("nGene", "nUMI", "percent.mito"),
        nCol = 3)
```

```{r seurat filter and normalize, echo=FALSE}
scData <- FilterCells(object = scData, 
                      subset.names = c("nGene", "percent.mito"),
                      low.thresholds = c(param$min_genes, -Inf), 
                      high.thresholds = c(Inf, 0.25))
scData <- NormalizeData(object = scData, normalization.method = "LogNormalize",
                        scale.factor = scalingFactorSeurat)
```

```{r seurat variable gene, echo=FALSE}
scData <- FindVariableGenes(object=scData)
```

The number of variable genes: `r length(x = scData@var.genes)`.

```{r scale and PCA calculation, echo=FALSE, message=FALSE, results='hide'}
scData <- ScaleData(object = scData, vars.to.regress = c("nUMI","percent.mito"))
scData <- RunPCA(object = scData, pc.genes = scData@var.genes,
                 do.print = TRUE, pcs.print = 1:5,
                 genes.print = 5)
scData <- ProjectPCA(object = scData, do.print = FALSE)
```

```{r plot PCA, echo=FALSE, fig.width=10, fig.height=15}
VizPCA(object = scData, pcs.use = 1:6)
```

```{r PCHeatmap, echo=FALSE, fig.width=10, fig.height=30}
PCHeatmap(object=scData, pc.use=1:20, cells.use=500, do.balanced=TRUE, 
    label.columns=FALSE, use.full=FALSE)
```

```{r JackStraw, echo=FALSE, fig.width=10, fig.height=25, warning=FALSE}
scData <- JackStraw(object=scData, num.replicate=100, display.progress=FALSE)
JackStrawPlot(object=scData, PCs = 1:20)
```

```{r PCElbowPlot, echo=FALSE}
PCElbowPlot(object=scData)
```

### Data availability

**Expression matrix**

The raw count matrix and tpm are available here:

```{r raw count matrix, echo=FALSE, results='asis', eval=TRUE}
rawCount <- as.matrix(assays(sce)$counts)
if(param$scProtocol == "smart-Seq2"){
  colnames(rawCount) <- colData(sce)$Name
}else if(param$scProtocol == "10x"){
  colnames(rawCount) <- colData(sce)$Barcode
}
ezWrite.table(rawCount, file="rawCount.txt",
              head=paste0(param$featureLevel, "_id"),
              sep="\t")
zip("rawCount.zip", files="rawCount.txt")

cat("\n")
cat(paste0("[", "rawCount.zip", "](", "rawCount.zip", ")"))
cat("\n")

if(param$scProtocol != "10x"){
  ## TODO: fix the CellRanger app to use standard reference annotation parameter
  ## Then enable it for 10x dataset
  tpm <- as.matrix(getTpm(sce))
  ezWrite.table(tpm, file="tpm.txt",
                head=paste0(param$featureLevel, "_id"),
                sep="\t")
  zip("tpm.zip", files="tpm.txt")
  cat("\n")
  cat(paste0("[", "tpm.zip", "](", "tpm.zip", ")"))
  cat("\n")
  invisible(file.remove(c("tpm.txt")))
}
invisible(file.remove(c("rawCount.txt")))
```

### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
