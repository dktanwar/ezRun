---
title: "SCCountQC"
author: "Functional Genomics Center Zurich"
output: 
  html_document:
    self_contained: false
    includes:
      in_header: fgcz_header.html
    css: fgcz.css
---

Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

```{r setup, include=FALSE}
require(SummarizedExperiment)
require(plotly)
require(scater)
require(ezRun)

#load("/export/local/scratch/gtan/p2497-SCCountQC/sce.rdata")

sceAllCells <- sce



param <- metadata(sce)$param
mlog <- metadata(sce)$mlog

param$minReadsPerCell = 1e4
param$minReadsPerGene = 3
param$minGenesDetected = 800 ## we should also filter genes that do not have param$minReadsPerGene for at least param$minGenesDetected

sce <- sce[, colSums(assays(sce)$counts) >= param$minReadsPerCell]
sce <- sce[, colSums(assays(sce)$counts >= param$minReadsPerGene) >= param$minGenesDetected]

seqAnno <- data.frame(rowData(sce), row.names=rownames(sce),
                      check.names = FALSE, stringsAsFactors=FALSE)
mito <- rownames(seqAnno)[grepl("^mt-", seqAnno$gene_name)]
x <- assays(sce)$counts
cell_info <- data.frame(row.names = colnames(x),
                        lib_size=colSums(x)/1e6, 
                        expr_genes = colSums(x>0), 
                        perc_mito=colSums(x[mito,])*100/colSums(x))

## sceFixName for section "Reads on top 50 genes" and "Expression metrics"
sceFixName <- sce
rownames(sceFixName) <- make.unique(rowData(sceFixName)$gene_name)
is.mito <- grepl("^mt-", rownames(sceFixName))
sceFixName <- calculateQCMetrics(sceFixName, feature_controls=list(Mt=is.mito))
libsize.drop <- isOutlier(sceFixName$total_counts, nmads=5, type="lower", log=TRUE)
feature.drop <- isOutlier(sceFixName$total_features, nmads=5, type="lower", log=TRUE)
sceFixName <- sceFixName[,!(libsize.drop | feature.drop )]

## datasetAllCells for section "Heatmap of reads per cell on the plate"
datasetAllCells <- data.frame(colData(sceAllCells),
                              check.names = FALSE, stringsAsFactors=FALSE)
```

## CountQC_Result {.tabset}

### Overview

* **Total Number of Cells:** `r ncol(sceAllCells)`

* **Number of cells removed:**  `r ncol(sceAllCells)-ncol(sce)`
  + cells with less than `r param$minReadsPerCell` reads aligned 
  + cells with less than`r param$minGenesDetected` genes that have at least `r param$minReadsPerGene` reads

* **Cells used:** `r ncol(sce)`

* **Median Genes per Cell** = `r as.integer(median(cell_info$expr_genes))`

* **Median Reads per Cell** = `r round(median(cell_info$lib_size*1e6),0)`

* Number of input reads = `r mlog["Number of input reads",2]`

* % of reads mapped to multiple loci = `r mlog["% of reads mapped to multiple loci",2]`

### #Genes detected in cells

Interactive plot showing the read counts vs the number of expressed genes for all cells. Each dot is a cell.

```{r, fig.width=8, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
xax <- list(
  title = "Read counts (million)",
  zeroline = FALSE
)
yax <- list(
  title = "Number of expressed genes",
  zeroline = FALSE
)
plot_ly(data=cell_info, x=~lib_size, y=~expr_genes, 
        text=rownames(cell_info),
        marker = list(color="deepskyblue3"), type='scatter') %>% 
  layout(xaxis = xax, yaxis = yax)
```

### QC metrics on the cells

Histograms of read counts, number of expressed genes and proportion of reads assigned to mitochondrial genes for all cells

```{r, fig.width=10, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
par(mfrow=c(1,3), mar=c(5.1, 4.1, 0.1, 0.1))
hist(cell_info$lib_size, xlab="Read counts (million)", main="",
     breaks=20, col="deepskyblue3", ylab="Number of cells")
hist(cell_info$expr_genes, xlab="Number of expressed genes", main="",
     breaks=20, col="deepskyblue3", ylab="Number of cells")
hist(cell_info$perc_mito, xlab="Mitochondrial proportion (%)",
     ylab="Number of cells", breaks=20, main="", col="deepskyblue3")
```

### Reads on top 50 genes

Percentage of total counts assigned to the top 50 most highly-abundant genes. For each gene, each bar represents the percentage assigned to that gene for a single cell, while the circle represents the average across all cells.

```{r, fig.width=6, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "highest-expression", n=50)
```

### Expression metrics

Number of cells with expression for a gene against mean expression level.

```{r, fig.width=8, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "exprs-freq-vs-mean")
```

### Heatmap of reads per cell on the plate

Sequenced reads on the plate layout.The heatmap values are in $log10$ scale. The colorScale ranges from half of median value to twice of median value.

```{r plate layout, echo=FALSE, message=FALSE, warning=FALSE}
plateMatrix <- plateStatistics(datasetAllCells)
plateMatrix$`user ready made`$`LibConc_100_800bp [Characteristic]`=NULL
if(!is.na(plateMatrix)){
  l <- htmltools::tagList()
  ## This is the way of plotting plotly figures within a loop in knitr code chunk
  for(plateName in names(plateMatrix)){
    for(colname in names(plateMatrix[[plateName]])){
      p <- heatmapPlate(plateMatrix[[plateName]][[colname]],
                        title=paste(plateName, colname, sep=": "),
                        center=TRUE, log10=TRUE)
      l[[paste(plateName, colname, sep=": ")]] <- as_widget(p)
    }
  }
  l
}
```


### Gene Detection Rates

```{r gene detection rates, fig.width=8, fig.height=8}
scePC = sce
rowData(scePC) = NULL #rowData(sce)[ , c("gene_name", "type", "biotypes", "gc", "width")]
#rownames(scePC) = rownames(sce)
scePC = scePC[seqAnno[rownames(scePC), "biotypes"] == "protein_coding", ]
widthOffset = 200
logWidthBreaks = c(9.5, 10.5, 11.5)
gcBreaks = c(0.42, 0.48, 0.53, 0.57, 0.62)
refWidthBin = "(9.5 - 10.5]" 
refGcBin = "(0.53 - 0.57]"
  ## define the gene strata
logWidth = log2(seqAnno[rownames(scePC), "width"] + widthOffset)
lwClasses = ezCut(logWidth, breaks = logWidthBreaks)
gcClasses = ezCut(seqAnno[rownames(scePC), "gc"], gcBreaks)
geneBins = tapply((1:nrow(scePC)), list(logWidth=lwClasses, gc=gcClasses), identity)

  
fracPresentByGene = rowMeans(assays(scePC)$counts > param$minReadsPerGene)
fracPresentBinned = ezMatrix(0, rows=rownames(geneBins), cols=colnames(geneBins))
for (i in 1:length(geneBins)){
  fracPresentBinned[i] = mean(fracPresentByGene[geneBins[[i]]])
}

ezHeatmap(fracPresentBinned[nrow(fracPresentBinned):1, ], lim=c(0, 0.2), Rowv = FALSE, Colv = FALSE, main="", colors=gray((1:256)/256),
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="", xlab="GC", ylab="log2 gene length", margins=c(8,8))


ezHeatmap(log2((fracPresentBinned[nrow(fracPresentBinned):1, ] + 1e-3) / fracPresentBinned[refWidthBin, refGcBin]), lim=c(-2, 2), Rowv = FALSE, Colv = FALSE, main="",
          colors=getBlueRedScale(),
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="", xlab="GC", ylab="log2 gene length", margins=c(8,8))


binCombs = expand.grid(logWidth=rownames(geneBins), gc=colnames(geneBins))
gcWidthScores = ezMatrix(NA, rows=paste(binCombs$logWidth, binCombs$gc), cols=colnames(scePC))
for (i in 1:nrow(binCombs)){
  idx = geneBins[[binCombs$logWidth[i], binCombs$gc[i]]]
  gcWidthScores[paste(binCombs$logWidth[i], binCombs$gc[i]), ] = colMeans(assays(scePC)$counts[idx, , drop=FALSE] > param$minReadsPerGene)
}

gcWidthScoresRel = log2((gcWidthScores + 0.01) / rowMeans(gcWidthScores))

ezHeatmap(gcWidthScores[ ,order(colSums(assays(scePC)$counts))], lim=c(0, 0.2), Rowv = FALSE, Colv = FALSE, main="", colors=gray((1:256)/256), labCol="",
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="", xlab="cells", ylab="bins", margins=c(8,8))


ezHeatmap(gcWidthScoresRel[ ,order(colSums(assays(scePC)$counts > 3))], lim=c(-2, 2), Rowv = TRUE, Colv = FALSE, main="", colors=getBlueRedScale(), labCol = "",
          cexRow=1, cexCol=1, key.xlab="detection bias", key.title="", xlab="cells", ylab="bins", margins=c(8,16))

```


### Cluster by GC and Length Profile


### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
