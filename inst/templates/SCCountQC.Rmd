---
title:  "`r metadata(sce)$param$name`"
author: "Functional Genomics Center Zurich"
output: 
  html_document:
    self_contained: false
    includes:
      in_header: fgcz_header.html
    css: fgcz.css
---

Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

```{r setup, include=FALSE}
require(SummarizedExperiment)
require(plotly)
require(scater)
require(ezRun)
require(DT)
require(htmltools)

# debug
# sce <- readRDS("/export/local/scratch/gtan/p2497-SCCountQC/20171222.A-SiCSeq_SCs_P5_SCCountQC/sce.rds")

sceAllCells <- sce

param <- metadata(sce)$param
mlog <- metadata(sce)$mlog

param$minReadsPerCell = 1e4
param$minReadsPerGene = 3
param$minGenesDetected = 400 ## we should also filter genes that do not have param$minReadsPerGene for at least param$minGenesDetected

sce <- sce[, colSums(assays(sce)$counts) >= param$minReadsPerCell]
sce <- sce[, colSums(assays(sce)$counts >= param$minReadsPerGene) >= param$minGenesDetected]

seqAnno <- data.frame(rowData(sce), row.names=rownames(sce),
                      check.names = FALSE, stringsAsFactors=FALSE)
mito <- rownames(seqAnno)[grepl("^mt-", seqAnno$gene_name)]
x <- assays(sce)$counts
cell_info <- data.frame(row.names = colnames(x),
                        lib_size=colSums(x)/1e6, 
                        expr_genes = colSums(x>0), 
                        perc_mito=colSums(x[mito,])*100/colSums(x))

## sceFixName for section "Reads on top 50 genes" and "Expression metrics"
sceFixName <- sce
rownames(sceFixName) <- make.unique(rowData(sceFixName)$gene_name)
is.mito <- grepl("^mt-", rownames(sceFixName))
sceFixName <- calculateQCMetrics(sceFixName, feature_controls=list(Mt=is.mito))
libsize.drop <- isOutlier(sceFixName$total_counts, nmads=5, type="lower", log=TRUE)
feature.drop <- isOutlier(sceFixName$total_features, nmads=5, type="lower", log=TRUE)
sceFixName <- sceFixName[,!(libsize.drop | feature.drop )]

## datasetAllCells for section "Heatmap of reads per cell on the plate"
datasetAllCells <- data.frame(colData(sceAllCells),
                              check.names = FALSE, stringsAsFactors=FALSE)
```

## CountQC_Result {.tabset}

### Overview

* **Total Number of Cells:** `r ncol(sceAllCells)`
* **Number of cells removed:**  `r ncol(sceAllCells)-ncol(sce)`
  + cells with less than `r param$minReadsPerCell` reads aligned 
  + cells with less than `r param$minGenesDetected` genes that have at least `r param$minReadsPerGene` reads
* **Cells used:** `r ncol(sce)`
* **Median Genes per Cell** = `r as.integer(median(cell_info$expr_genes))`
* **Median Reads per Cell** = `r round(median(cell_info$lib_size*1e6),0)`
* Number of input reads = `r mlog["Number of input reads",2]`
* % of reads mapped to multiple loci = `r mlog["% of reads mapped to multiple loci",2]`

### #Genes detected in cells

Interactive plot showing the read counts vs the number of expressed genes for all cells. Each dot is a cell.

```{r genes detected in cells, fig.width=8, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
xax <- list(
  title = "Read counts (million)",
  zeroline = FALSE
)
yax <- list(
  title = "Number of expressed genes",
  zeroline = FALSE
)
plot_ly(data=cell_info, x=~lib_size, y=~expr_genes, 
        text=rownames(cell_info),
        marker = list(color="deepskyblue3"), type='scatter') %>% 
  layout(xaxis = xax, yaxis = yax)
```

### QC metrics on the cells

Histograms of read counts, number of expressed genes and proportion of reads assigned to mitochondrial genes for all cells

```{r QC metrics on the cells, fig.width=10, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
par(mfrow=c(1,3), mar=c(5.1, 4.1, 0.1, 0.1))
hist(cell_info$lib_size, xlab="Read counts (million)", main="",
     breaks=20, col="deepskyblue3", ylab="Number of cells")
hist(cell_info$expr_genes, xlab="Number of expressed genes", main="",
     breaks=20, col="deepskyblue3", ylab="Number of cells")
hist(cell_info$perc_mito, xlab="Mitochondrial proportion (%)",
     ylab="Number of cells", breaks=20, main="", col="deepskyblue3")
```

### Reads on top 50 genes

Percentage of total counts assigned to the top 50 most highly-abundant genes. For each gene, each bar represents the percentage assigned to that gene for a single cell, while the circle represents the average across all cells.

```{r top 50 genes, fig.width=6, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "highest-expression", n=50)
```

### Expression metrics

Number of cells with expression for a gene against mean expression level.

```{r expression metrics, fig.width=8, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "exprs-freq-vs-mean")
```

### Heatmap of reads per cell on the plate

Sequenced reads on the plate layout.The heatmap values are in $log10$ scale. The colorScale ranges from half of median value to twice of median value.

```{r plate layout, echo=FALSE, message=FALSE, warning=FALSE}
plateMatrix <- plateStatistics(datasetAllCells)

if(!is.na(plateMatrix)){
  plateMatrix$`user ready made`$`LibConc_100_800bp [Characteristic]`=NULL
  l <- htmltools::tagList()
  ## This is the way of plotting plotly figures within a loop in knitr code chunk
  for(plateName in names(plateMatrix)){
    for(colname in names(plateMatrix[[plateName]])){
      p <- heatmapPlate(plateMatrix[[plateName]][[colname]],
                        title=paste(plateName, colname, sep=": "),
                        center=TRUE, log10=TRUE,
                        width = 500*(1 + sqrt(5))/2, height = 500)
      ## tagList ignores chunk optiosn for figrue size.
      ## control the size in plotly.
      l[[paste(plateName, colname, sep=": ")]] <- as_widget(p)
    }
  }
  l
}
```


### Gene Detection Rates

```{r gene detection rates, fig.width=8, fig.height=8, echo=FALSE, message=FALSE, warning=FALSE}
scePC = sce
rowData(scePC) = NULL
scePC = scePC[seqAnno[rownames(scePC), "biotypes"] == "protein_coding", ]
widthOffset = 200
logWidthBreaks = c(9.5, 10.5, 11.5)
gcBreaks = c(0.42, 0.48, 0.53, 0.57, 0.62)
refWidthBin = "(9.5 - 10.5]" 
refGcBin = "(0.53 - 0.57]"
  ## define the gene strata
logWidth = log2(seqAnno[rownames(scePC), "featWidth"] + widthOffset)
lwClasses = ezCut(logWidth, breaks = logWidthBreaks)
gcClasses = ezCut(seqAnno[rownames(scePC), "gc"], gcBreaks)
geneBins = tapply((1:nrow(scePC)), list(logWidth=lwClasses, gc=gcClasses), identity)

fracPresentByGene = rowMeans(assays(scePC)$counts > param$minReadsPerGene)
fracPresentBinned = ezMatrix(0, rows=rownames(geneBins), cols=colnames(geneBins))
for (i in 1:length(geneBins)){
  fracPresentBinned[i] = mean(fracPresentByGene[geneBins[[i]]])
}

ezHeatmap(fracPresentBinned[nrow(fracPresentBinned):1, ], lim=c(0, 0.2), Rowv = FALSE, Colv = FALSE, main="", colors=gray((1:256)/256),
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="", xlab="GC", ylab="log2 gene length", margins=c(8,8))


ezHeatmap(log2((fracPresentBinned[nrow(fracPresentBinned):1, ] + 1e-3) / fracPresentBinned[refWidthBin, refGcBin]), lim=c(-2, 2), Rowv = FALSE, Colv = FALSE, main="",
          colors=getBlueRedScale(),
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="", xlab="GC", ylab="log2 gene length", margins=c(8,8))


binCombs = expand.grid(logWidth=rownames(geneBins), gc=colnames(geneBins))
gcWidthScores = ezMatrix(NA, rows=paste(binCombs$logWidth, binCombs$gc), cols=colnames(scePC))
for (i in 1:nrow(binCombs)){
  idx = geneBins[[binCombs$logWidth[i], binCombs$gc[i]]]
  gcWidthScores[paste(binCombs$logWidth[i], binCombs$gc[i]), ] = colMeans(assays(scePC)$counts[idx, , drop=FALSE] > param$minReadsPerGene)
}

gcWidthScoresRel = log2((gcWidthScores + 0.01) / rowMeans(gcWidthScores))

ezHeatmap(gcWidthScores[ ,order(colSums(assays(scePC)$counts) > 3)], lim=c(0, 0.2), Rowv = FALSE, Colv = FALSE, main="", colors=gray((1:256)/256), labCol="",
          cexRow=1, cexCol=1, key.xlab="detection rate", key.title="", xlab="cells", ylab="bins", margins=c(8,8))


ezHeatmap(gcWidthScoresRel[ ,order(colSums(assays(scePC)$counts > 3))], lim=c(-2, 2), Rowv = TRUE, Colv = FALSE, main="", colors=getBlueRedScale(), labCol = "",
          cexRow=1, cexCol=1, key.xlab="detection bias", key.title="", xlab="cells", ylab="bins", margins=c(8,16))

```

### Picard Metrics
A overview of scRNA-Seq QC metrics from Picard over the plate. 
For the detais of the metrics, please refer to 
https://broadinstitute.github.io/picard/picard-metric-definitions.html

```{r picard setup, echo=FALSE}
cd <- data.frame(colData(sceAllCells), check.names = FALSE)
cd$nGenesDetected <- colSums(assays(sceAllCells)$counts > 3)
```

```{r picard plot, echo=FALSE, fig.width=20, fig.height=6}
plateMatrix <- plateStatistics(cd, 
                               colname=c("PF_READS", "nGenesDetected",
                                         "PCT_RIBOSOMAL_BASES", "PF_READS_ALIGNED",
                                         "PF_MISMATCH_RATE", "PCT_ADAPTER",
                                         "PCT_MRNA_BASES", "MEDIAN_CV_COVERAGE",
                                         "MEDIAN_5PRIME_BIAS", "MEDIAN_3PRIME_BIAS",
                                         "PERCENT_DUPLICATION"))
metricsNonLog <- c("PF_MISMATCH_RATE", "PCT_ADAPTER", "MEDIAN_5PRIME_BIAS",
                   "MEDIAN_3PRIME_BIAS", "PERCENT_DUPLICATION")
plateName <- names(plateMatrix)[1]
l <- htmltools::tagList()
for(plateName in names(plateMatrix)){
  for(colname in setdiff(names(plateMatrix[[plateName]]), 
                         c("PF_READS", "nGenesDetected"))){
    matrix2PlotOrigin <- matrix2Plot <- plateMatrix[[plateName]][[colname]]
    if(colname %in% metricsNonLog){
      ## non-log scale
      med_matrix2Plot <- median(matrix2Plot, na.rm=TRUE)
      range_colour <- sort(c(0, 2*med_matrix2Plot)) ## in case for negative values
      p1 <- heatmapPlate(matrix2PlotOrigin, log10 = FALSE, center = TRUE,
                         title=paste(plateName, colname, sep=": "),
                         colors="RdYlGn")
    }else{
      ## log-scale
      stopifnot(all(matrix2Plot >= 0)) ## It has to be positive to log
      matrix2Plot[matrix2Plot==0] <- min(0.25 * matrix2Plot[matrix2Plot >0],
                                         na.rm = TRUE)
      matrix2Plot <- log10(matrix2Plot)
      med_matrix2Plot <- median(matrix2Plot, na.rm=TRUE)
      range_colour <- c(med_matrix2Plot-log10(2), med_matrix2Plot+log10(2))
      p1 <- heatmapPlate(matrix2PlotOrigin, log10=TRUE, center = TRUE,
                       title=paste(plateName, colname, sep=": "), 
                       colors="RdYlGn")
    }
    
    ## To make the scatter plot have the same colourscale as heatmap
    ## There are two options:
    ## 1. fake the data into cd2 with minimal and maximal colourrange.
    ##    Certainly it's not elegent.
    # cd2 <- data.frame(PF_READS=c(-1, -1, c(plateMatrix[[plateName]]$PF_READS)),
    #                   nGenesDetected=c(-1,-1, c(plateMatrix[[plateName]]$nGenesDetected)),
    #                   metric=c(range_colour, c(matrix2Plot)),
    #                   metricOriginal=c(range_colour, c(plateMatrix[[plateName]][[colname]]))
    #                   )
    ## color by metric, plot value by metricOriginal
    ## 2. use the cmin and cmax in scatter plot. The colour of points is right,
    ##   but the color bar is wrong.
    ##   Anyway we only use the color bar from heatmap.
    ## I use option 2.
    cd2 <- data.frame(PF_READS=c(plateMatrix[[plateName]]$PF_READS),
                      nGenesDetected=c(plateMatrix[[plateName]]$nGenesDetected),
                      matrix2Plot=c(matrix2Plot),
                      matrix2PlotOrigin=c(matrix2PlotOrigin),
                      position=apply(expand.grid(rownames(matrix2PlotOrigin),
                                                 colnames(matrix2PlotOrigin)), 
                                     1, paste, collapse=": ")
                      )
    if(colname == "PF_READS_ALIGNED"){
      cd2 <- transform(cd2, matrix2PlotOrigin=matrix2PlotOrigin/PF_READS)
    }
    p2 <- plot_ly(data = cd2, x = ~PF_READS, y = ~nGenesDetected,
                    color = ~matrix2Plot, text=~position,
                    type="scatter", mode = 'markers', colors="RdYlGn",
                    marker=list(cmin=range_colour[1], cmax=range_colour[2])) %>%
            hide_colorbar() 
    p3 <- plot_ly(data = cd2, x = ~PF_READS, y = ~matrix2PlotOrigin,
                  color = ~matrix2Plot, text=~position,
                  type="scatter", mode = 'markers', colors="RdYlGn",
                  marker=list(cmin=range_colour[1], cmax=range_colour[2])) %>%
            hide_colorbar()
    p2 <- p2 %>%
              layout(xaxis=list(type="log"),
                     yaxis=list(type="log", title="# of Genes Detected"))
    if(colname %in% metricsNonLog){
      p3 <- p3 %>%
              layout(xaxis=list(type="log"), yaxis=list(title=colname))
    }else{
      p3 <- p3 %>%
            layout(xaxis=list(type="log"),
                   yaxis=list(type="log", title=colname))
    }
    l[[paste(plateName, colname, sep=": ")]] <- 
      as_widget(subplot(p1, p2, p3, nrows=1, titleX=TRUE, titleY=TRUE) %>%
                    layout(showlegend = FALSE))
  }
}
l
```

### Picard Metrics Summary
```{r metrics, echo=FALSE}
metricsDT <- colData(sce)[, (tail(grep("\\[File\\]", colnames(colData(sce))), 1)+1):ncol(colData(sce))]
datatable(data.frame(metricsDT, check.names = FALSE), filter = 'top',
          caption="scRNASeq QC Metrics")
```

```{r 5 prime bias, echo=FALSE, eval=FALSE}
x <- list(
  title = "Prime bias"
)

p <- plot_ly(alpha = 0.6) %>%
  add_histogram(x = ~colData(sce)$`bias5`, name="5 prime bias") %>%
  add_histogram(x = ~colData(sce)$`bias3`, name="3 prime bias") %>%
  layout(barmode = "overlay", title="Mean prime bias",
         xaxis=x)

p

p2 <- plot_ly(alpha = 0.6) %>%
  add_histogram(x = ~colData(sce)$`MEDIAN_5PRIME_BIAS`, name="5 prime bias") %>%
  add_histogram(x = ~colData(sce)$`MEDIAN_3PRIME_BIAS`, name="3 prime bias") %>%
  layout(barmode = "overlay", title="Median prime bias: Picard",
         xaxis=x)
p2
```

### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
