---
title: "SCCountQC"
author: "Functional Genomics Center Zurich"
output: 
  html_document:
    self_contained: false
    includes:
      in_header: fgcz_header.html
    css: fgcz.css
---

Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

```{r setup, include=FALSE}
require(SummarizedExperiment)
require(plotly)
require(scater)
require(ezRun)

load("/export/local/scratch/gtan/p2497-SCCountQC/sce.rdata")

sceAllCells <- sce

param <- metadata(sce)$param
mlog <- metadata(sce)$mlog

param$minSCCount <- 1e4

sce <- sce[, colSums(assays(sce)$counts) > param$minSCCount]

seqAnno <- data.frame(rowData(sce), row.names=rownames(sce),
                      check.names = FALSE, stringsAsFactors=FALSE)
mito <- rownames(seqAnno)[grepl("^mt-", seqAnno$gene_name)]
x <- assays(sce)$counts
cell_info <- data.frame(row.names = colnames(x),
                        lib_size=colSums(x)/1e6, 
                        expr_genes = colSums(x>0), 
                        perc_mito=colSums(x[mito,])*100/colSums(x))

## sceFixName for section "Reads on top 50 genes" and "Expression metrics"
sceFixName <- sce
rownames(sceFixName) <- make.unique(rowData(sceFixName)$gene_name)
is.mito <- grepl("^mt-", rownames(sceFixName))
sceFixName <- calculateQCMetrics(sceFixName, feature_controls=list(Mt=is.mito))
libsize.drop <- isOutlier(sceFixName$total_counts, nmads=5, type="lower", log=TRUE)
feature.drop <- isOutlier(sceFixName$total_features, nmads=5, type="lower", log=TRUE)
sceFixName <- sceFixName[,!(libsize.drop | feature.drop )]

## datasetAllCells for section "Heatmap of reads per cell on the plate"
datasetAllCells <- data.frame(colData(sceAllCells),
                              check.names = FALSE, stringsAsFactors=FALSE)
```

## CountQC_Result {.tabset}

### Overview

**Number of Cells** = `r ncol(x)`

**Median Genes per Cell** = `r as.integer(median(cell_info$expr_genes))`

**Median Reads per Cell** = `r round(median(cell_info$lib_size*1e6),0)`

We filtered out `r ncol(sceAllCells)-ncol(sce)` cells with < `r param$minSCCount` reads.

Number of input reads = `r mlog["Number of input reads",2]`

% of reads mapped to multiple loci = `r mlog["% of reads mapped to multiple loci",2]`

### #Genes detected in cells

Interactive plot showing the read counts vs the number of expressed genes for all cells. Each dot is a cell.

```{r, fig.width=8, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
xax <- list(
  title = "Read counts (million)",
  zeroline = FALSE
)
yax <- list(
  title = "Number of expressed genes",
  zeroline = FALSE
)
plot_ly(data=cell_info, x=~lib_size, y=~expr_genes, 
        text=rownames(cell_info),
        marker = list(color="deepskyblue3"), type='scatter') %>% 
  layout(xaxis = xax, yaxis = yax)
```

### QC metrics on the cells

Histograms of read counts, number of expressed genes and proportion of reads assigned to mitochondrial genes for all cells

```{r, fig.width=10, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}
par(mfrow=c(1,3), mar=c(5.1, 4.1, 0.1, 0.1))
hist(cell_info$lib_size, xlab="Read counts (million)", main="",
     breaks=20, col="deepskyblue3", ylab="Number of cells")
hist(cell_info$expr_genes, xlab="Number of expressed genes", main="",
     breaks=20, col="deepskyblue3", ylab="Number of cells")
hist(cell_info$perc_mito, xlab="Mitochondrial proportion (%)",
     ylab="Number of cells", breaks=20, main="", col="deepskyblue3")
```

### Reads on top 50 genes

Percentage of total counts assigned to the top 50 most highly-abundant genes. For each gene, each bar represents the percentage assigned to that gene for a single cell, while the circle represents the average across all cells.

```{r, fig.width=6, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "highest-expression", n=50)
```

### Expression metrics

Number of cells with expression for a gene against mean expression level.

```{r, fig.width=8, fig.height=6, echo=FALSE, message=FALSE, warning=FALSE}
plotQC(sceFixName, type = "exprs-freq-vs-mean")
```

### Heatmap of reads per cell on the plate

Sequenced reads on the plate layout.The heatmap values are in $log10$ scale. The colorScale ranges from half of median value to twice of median value.

```{r plate layout, echo=FALSE, message=FALSE, warning=FALSE}
plateMatrix <- plateStatistics(datasetAllCells)
plateMatrix$`user ready made`$`LibConc_100_800bp [Characteristic]`=NULL
if(!is.na(plateMatrix)){
  l <- htmltools::tagList()
  ## This is the way of plotting plotly figures within a loop in knitr code chunk
  for(plateName in names(plateMatrix)){
    for(colname in names(plateMatrix[[plateName]])){
      p <- heatmapPlate(plateMatrix[[plateName]][[colname]],
                        title=paste(plateName, colname, sep=": "),
                        center=TRUE, log10=TRUE)
      l[[paste(plateName, colname, sep=": ")]] <- as_widget(p)
    }
  }
  l
}
```

### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
