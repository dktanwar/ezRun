---
title: "`r if (exists('reportTitle')) reportTitle else 'Fastq Screen'`"
author: "Functional Genomics Center Zurich"
output: 
  html_document:
    self_contained: false
    lib_dir: rmarkdownLib
    includes:
      in_header: fgcz_header.html
    css: fgcz.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(knitr)
require(kableExtra)
require(plotly)

output <- readRDS("output.rds")
param <- readRDS("param.rds")
input <- readRDS("input.rds")
rawScreenResult <- readRDS("rawScreenResult.rds")
procScreenResult <- readRDS("procScreenResult.rds")
virusResult <- readRDS("virusResult.rds")
refseqResult = readRDS("refseqResult.rds")
krakenResult <- readRDS("krakenResult.rds")
rRNAstrandResult <- readRDS("rRNAstrandResult.rds")
dataset = input$meta
samples = input$getNames()

debug <- FALSE
```
Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

## FastqScreen_Result {.tabset}


### FastqScreen Mapping Rates to Adapters and rRNA

The raw reads are checked for adapter content. A local alignment using [Bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml) is performed. Reads occuring from adapter dimers and adapter contamination at the 3' end can be discovered. 

```{r overview plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
m <- list(l = 80, r = 80, b = 200, t = 100, pad = 0) # more margin space

percentMapped = sapply(rawScreenResult, function(x){100 - x$"%Unmapped"})

# MappingRateAdapters
p <- plot_ly(x=samples,
             y=percentMapped,
             type="bar") %>%
  layout(title = "MappingRate to Adapters - Bowtie2, local Alignment",
         yaxis = list(title = "MappedReads in %", range = c(0,100)),
         margin = m)
p
```

A Bowtie2 end-to-end alignment is performed to estimate the overall rRNA content of the libraries. [SILVA](https://www.arb-silva.de/) is used as the reference database. The read orientation can be used to check if the sequenced libraries preserve the strand information.

```{r overview rRNA plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
# rRNA Mapping
rRnaPercentMapped = rRNAstrandResult[ , c("Sense", "Antisense")] / rRNAstrandResult$`Read Count` * 100
rRnaPercentMapped$sample = rownames(rRnaPercentMapped)
p <- plot_ly(rRnaPercentMapped, x=~sample, y=~Sense, 
             type="bar", name="sense") %>%
    add_trace(y = ~Antisense, name = "antisense") %>%
  layout(title = "rRNA Silva Mapping - Bowtie2, end-to-end Alignment",
         yaxis = list(title = "rRNA-Mapping-Rate in %"),
         xaxis = list(title = ""),
         barmode = 'stack', margin = m)
p
```

### FastqScreen Mapping Per Sample

Each sample is mapped against multiple references using [FastqScreen](https://www.bioinformatics.babraham.ac.uk/projects/fastq_screen/). This includes the most common model organisms, ribosomal RNA references (large and small subunit) based on SILVA on several taxonomic levels and typical biological and technical contaminants in NGS libraries (tRNAs, PhIX, Mycoplasma, UniVec).

```{r FastqScreenPerSample, echo=FALSE, results='hide', warning=FALSE, message=FALSE, eval=!debug}
for (nm in samples){
  par(mar=c(10.1, 4.1, 4.1, 2.1))
  x = procScreenResult[[nm]][ , c("%One_hit_one_genome", "%Multiple_hits_one_genome", 
                                  "%One_hit_multiple_genomes", "%Multiple_hits_multiple_genomes")]
  if (nrow(x) > 0){
    x = x[ , c("%One_hit_one_genome", "%Multiple_hits_one_genome", 
                                  "%One_hit_multiple_genomes", "%Multiple_hits_multiple_genomes")]
    bplt = barplot(t(x), las=2, ylim=c(0,100), 
                   legend.text=T, ylab="Mapped Reads in %", main=nm, names.arg=rep('', nrow(x)))
      text(x = bplt, y = par("usr")[3] - 2, srt = 45, adj = 1, labels = rownames(x), xpd = TRUE)
  } else {
    plot(1,1, type="n", axes=FALSE, main=nm, xlab="", ylab="", frame=TRUE)
    text(1,1, "no hits found")
  }
}
```

### Mapping to RefSeq mRNA Per Sample

A mapping against all mRNAs in RefSeq can be useful to estimate the fraction reads which is specific for exonic regions. Furthermore contaminations with other species e.g. due to xenograft experiments can be discovered.


```{r mRNAMultiSample prepare, echo=FALSE, results='hide', warning=FALSE, message=FALSE, eval=!debug}
speciesPerSample <- sapply(refseqResult, function(listElem) return(rownames(listElem)))
readFractionPerSample_uniq <- sapply(refseqResult, function(listElem) return(listElem$UniqueSpeciesPercent))
readFractionPerSample_multi <- sapply(refseqResult, function(listElem) return(listElem$MultipleSpeciesPercent))
uniqueSpecies <- unique(as.vector(unlist(speciesPerSample)))
uniqueSpecies <- uniqueSpecies[!is.na(uniqueSpecies)]

refSeqResult_DF_uniq <- data.frame(Species = uniqueSpecies, row.names = uniqueSpecies)
for (nm in samples){
    refSeqResult_DF_uniq[[nm]] <- 0
    if(is.list(speciesPerSample)){
      refSeqResult_DF_uniq[speciesPerSample[[nm]], nm] = readFractionPerSample_uniq[[nm]]
    } else {
      refSeqResult_DF_uniq[speciesPerSample[,nm], nm] = readFractionPerSample_uniq[,nm]
    }
}
refSeqResult_DF_uniq <- refSeqResult_DF_uniq[rowSums(refSeqResult_DF_uniq[,samples]) > 0,]
refSeqResult_DF_uniq <- refSeqResult_DF_uniq[order(apply(refSeqResult_DF_uniq[,samples], 1, mean), decreasing = TRUE),]

refSeqResult_DF_multi <- data.frame(Species = uniqueSpecies, row.names = uniqueSpecies)
for (nm in samples){
    refSeqResult_DF_multi[[nm]] <- 0
    if(is.list(speciesPerSample)){
      refSeqResult_DF_multi[speciesPerSample[[nm]], nm] = readFractionPerSample_multi[[nm]]
    } else {
      refSeqResult_DF_multi[speciesPerSample[,nm], nm] = readFractionPerSample_multi[,nm]
    }
}
refSeqResult_DF_multi <- refSeqResult_DF_multi[rownames(refSeqResult_DF_multi) %in% rownames(refSeqResult_DF_uniq),]
refSeqResult_DF_multi <- refSeqResult_DF_multi[rownames(refSeqResult_DF_uniq),]
```

```{r RefTopHit1 plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
m <- list(l = 80, r = 80, b = 200, t = 100, pad = 0)
if (nrow(refSeqResult_DF_uniq) > 0){
  i = 1
  data <- unlist(refSeqResult_DF_uniq[i, samples]) + unlist(refSeqResult_DF_multi[i, samples])
  p <- plot_ly(x=samples,
             y=data,
             type="bar") %>%
  layout(title = paste0('TopHit', i,':', rownames(refSeqResult_DF_uniq)[i], ' (Unique + MultiHits)'),
         yaxis = list(title = "MappedReads in %", range = c(0,100)),
         margin = m)
  p
}
```

```{r RefTopHit2 plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
m <- list(l = 80, r = 80, b = 200, t = 100, pad = 0)
if (nrow(refSeqResult_DF_uniq) > 1){
  i = 2
  data <- unlist(refSeqResult_DF_uniq[i, samples]) + unlist(refSeqResult_DF_multi[i, samples])
  p <- plot_ly(x=samples,
             y=data,
             type="bar") %>%
  layout(title = paste0('TopHit', i,':', rownames(refSeqResult_DF_uniq)[i], ' (Unique + MultiHits)'),
         yaxis = list(title = "MappedReads in %", range = c(0,100)),
         margin = m)
  p
}
```

```{r RefTopHit3 plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
m <- list(l = 80, r = 80, b = 200, t = 100, pad = 0)
if (nrow(refSeqResult_DF_uniq) > 2){
  i = 3
  data <- unlist(refSeqResult_DF_uniq[i, samples]) + unlist(refSeqResult_DF_multi[i, samples])
  p <- plot_ly(x=samples,
             y=data,
             type="bar") %>%
  layout(title = paste0('TopHit', i,':', rownames(refSeqResult_DF_uniq)[i], ' (Unique + MultiHits)'),
         yaxis = list(title = "MappedReads in %", range = c(0,100)),
         margin = m)
  p
}
```

```{r mRNAPerSample, echo=FALSE, results='hide', warning=FALSE, message=FALSE, eval=!debug}
if(length(samples) > 100){
  cat('Skipped: > 100 Samples')
} else {
  for (nm in samples){
        par(mar=c(10.1, 4.1, 4.1, 2.1))
        x = refseqResult[[nm]]
        if (is.null(x)) x = matrix(0, 2, 1, dimnames=list(c('UniqueSpeciesHits','MultipleSpeciesHits'),'Misc'))
        bplot = barplot(t(x), col=c("royalblue3", "lightblue"), las=2, ylim=c(0,100),
                        legend.text=T, ylab="Mapped Reads in %", main=nm, names.arg=rep('',nrow(x)) )
        text(y=t(x)[ 1,] + 5, x=bplot, font = 2, labels=t(x)[ 1, ], cex=1.1, col='black')
        text(x = bplot, y = par("usr")[3] - 2, srt = 45, adj = 1, 
             labels = rownames(x), xpd = TRUE)
    }
  }
```

### Mapping to Genomes with Kraken2

[Kraken2](https://ccb.jhu.edu/software/kraken2/) is a tool to perform a taxonomic classification based on k-mer matches. The reference includes Refseq bacteria, archaea, viral libraries and the GRCh38 human genome. It's especially useful to discover bacterial contamination (e.g. Mycoplasma in cultivated cells.)


#### 1. MultiSample Barplots for top hits

```{r KrakenTopHitPrepare, echo=FALSE, results='hide', warning=FALSE, message=FALSE, eval=!debug}
speciesPerSample <- sapply(krakenResult, function(listElem) return(listElem$name))
readFractionPerSample <- sapply(krakenResult, function(listElem) return(listElem$readPercentage))
uniqueSpecies <- unique(as.vector(unlist(speciesPerSample)))
uniqueSpecies <- uniqueSpecies[!is.na(uniqueSpecies)]
krakenResult_DF <- data.frame(Species = uniqueSpecies, row.names = uniqueSpecies)
for (nm in samples){
    krakenResult_DF[[nm]] <- 0
      if(is.list(speciesPerSample)){
        if(all(!is.na(readFractionPerSample[[nm]]))){
        krakenResult_DF[speciesPerSample[[nm]], nm] = readFractionPerSample[[nm]]
        }
      } else {
         if(all(!is.na(readFractionPerSample[,nm]))){
          krakenResult_DF[speciesPerSample[,nm], nm] = readFractionPerSample[,nm]
         }
      }
}
krakenResult_DF <- krakenResult_DF[rowSums(krakenResult_DF[,samples]) > 0,]
krakenResult_DF <- krakenResult_DF[order(apply(krakenResult_DF[,samples], 1, mean), decreasing = TRUE),]
```

```{r KrakenTopHit1 plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
m <- list(l = 80, r = 80, b = 200, t = 100, pad = 0)
if (nrow(krakenResult_DF) > 0){
  i = 1
  data <- unlist(krakenResult_DF[i, samples])
  p <- plot_ly(x=samples,
             y=data,
             type="bar") %>%
  layout(title = paste0('TopHit', i,':', krakenResult_DF$Species[i]),
         yaxis = list(title = "MappedReads in %", range = c(0,max(data))),
         margin = m)
  p
}
```

```{r KrakenTopHit2 plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
m <- list(l = 80, r = 80, b = 200, t = 100, pad = 0)
if (nrow(krakenResult_DF) > 1){
  i <- 2
  data <- unlist(krakenResult_DF[i, samples])
  p <- plot_ly(x=samples,
             y=data,
             type="bar") %>%
  layout(title = paste0('TopHit', i,':', krakenResult_DF$Species[i]),
         yaxis = list(title = "MappedReads in %", range = c(0,max(data))),
         margin = m)
  p
}
```

```{r KrakenTopHit3 plotly, fig.height=7, fig.width=min(max(7, 7+(length(samples)-20)*0.2), 30), echo=FALSE, warning=FALSE, message=FALSE}
m <- list(l = 80, r = 80, b = 200, t = 100, pad = 0)
if (nrow(krakenResult_DF) > 2){
  i <- 3
  data <- unlist(krakenResult_DF[i, samples])
  p <- plot_ly(x=samples,
             y=data,
             type="bar") %>%
  layout(title = paste0('TopHit', i,':', krakenResult_DF$Species[i]),
         yaxis = list(title = "MappedReads in %", range = c(0,max(data))),
         margin = m)
  p
}
```
#### 2. Per sample barplots
- Abundances above 5% are truncated

```{r KrakenPerSample, echo=FALSE, results='hide', warning=FALSE, message=FALSE, eval=!debug}
if(length(samples) > 100){
  cat('Skipped: > 100 Samples')
} else {
  for (nm in samples){
      x = krakenResult_DF[[nm]]
      par(mar=c(15.1, 6.1, 4.1, 2.1))
      if (length(x) > 0){
          bplot <- barplot(x, names.arg = rep('',length(x)), col = 'royalblue3', 
                           main = nm, ylab = 'Mapped Reads in %', las = 2, ylim=c(0, 5))
          text(x = bplot, y = par("usr")[3] - 0.3, srt = 45, adj = 1, 
               labels = krakenResult_DF$Species, xpd = TRUE)
      }
  }
}
```

### Human pathogens check

This check includes a Bowtie2 mapping and is currently only performed for human samples. It uses all unmapped reads of the FastqScreen mapping as input and maps these reads against several common human pathogens (Bacteria and Viruses).

```{r virus, echo=FALSE, results='hide', warning=FALSE, message=FALSE, eval=!debug}
if(param[['virusCheck']]){
  for (nm in samples){ 
    par(mar=c(18.1, 7.1, 2.1, 2.1))
    x = virusResult[[nm]]
    if (is.null(x)) x = matrix(0, 2, 1, dimnames=list(c('UniqueSpeciesHits','MultipleSpeciesHits'),'Misc'))
    bplot = barplot(t(x), col=c("royalblue3", "lightblue"), las = 2, ylim = c(0,100),
                    legend.text=T, ylab="Mapped Reads in %", main=nm, names.arg=rep('',nrow(x)) )
    text(y=t(x)[ 1,] + 5, x=bplot, font = 2, labels=t(x)[ 1, ], cex = 1.1, col = 'black')
    text(x = bplot, y = par("usr")[3] - 2, srt = 60, adj = 1, 
         labels = rownames(x), xpd = TRUE)
  }
} else {
  cat("not run")
}
```


### RIN

#### RIN vs Read Count
```{r rin1, echo=FALSE, message=FALSE, warning=FALSE}
if (nrow(dataset) > 1){
  rinCol <- colnames(dataset)[grep('^RIN', colnames(dataset))]
  if(length(rinCol) == 1){
    a <- makeScatterplot(dataset, colname1 = rinCol, colname2='Read Count')
    a
  }
}
```

#### RIN vs LibConc
```{r rin2, echo=FALSE, message=FALSE, warning=FALSE}
if (nrow(dataset) > 1){
  rinCol <- colnames(dataset)[grep('^RIN', colnames(dataset))]
  if(length(rinCol) == 1){
    libQuant <- colnames(dataset)[grep('LibConc_100_800bp', colnames(dataset))]  
    if(length(libQuant) == 1){
      b <- makeScatterplot(dataset, colname1 = rinCol, colname2=libQuant)
      b
    }
  }
}
```

#### RIN vs rRNA content
```{r rin3, echo=FALSE, message=FALSE, warning=FALSE}
if (nrow(dataset) > 1){
  rinCol <- colnames(dataset)[grep('RIN', colnames(dataset))]
  if(length(rinCol) == 1){
    dataset[['rRNA_Percent']] <- (rRNAstrandResult$Sense + rRNAstrandResult$Antisense) / rRNAstrandResult$`Read Count` * 100
    c <- makeScatterplot(dataset, colname1 = rinCol, colname2='rRNA_Percent')
    c
  }
}
```

### Settings
```{r setting, echo=FALSE}
getAppVer <- function(appName) { sub("^.+/([^/]+)$", "\\1", Sys.getenv(appName)) }
settings = character()
settings["Configuration File:"] = param$confFile
settings["RefSeq mRNA Reference:"] = REFSEQ_mRNA_REF
settings["FastqScreen Version:"] = getAppVer("FastQScreen")
settings["Bowtie2 Version:"] = getAppVer("Bowtie2")
settings["Bowtie2 Parameters:"] = param$cmdOptions
settings["Minimum AlignmentScore:"] = param$minAlignmentScore
settings["TopSpecies:"] = param$nTopSpecies
kable(as.data.frame(settings), col.names=NA, row.names=TRUE, format="html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F,
                position = "left")
```

### Input Dataset
```{r, echo=FALSE, message=FALSE}
ezInteractiveTableRmd(values=dataset)
```

### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
