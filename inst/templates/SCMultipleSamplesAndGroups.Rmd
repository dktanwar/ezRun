---
author: "Functional Genomics Center Zurich"
output: 
  html_document:
    self_contained: true
    includes:
      in_header: fgcz_header.html
    css: fgcz.css
editor_options: 
  chunk_output_type: console
---

Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

```{r setup, include=FALSE}
library(SummarizedExperiment)
library(ggplot2)
library(ggridges)
library(cowplot)
library(tibble)
library(dplyr)
library(readr)
library(kableExtra)
library(tidyr)
library(pheatmap)
library(scater)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")

#to test
# library(HDF5Array)
# library(SingleR)
# library(AUCell)
# library(ezRun, lib.loc = "~/myRpackages")
# sce <- loadHDF5SummarizedExperiment("sce_h5")
# param = metadata(sce)$param
# pvalue_allMarkers <- 0.05
```

```{r}
output <- metadata(sce)$output
```

```{r javascript, results='asis'}
jsFile = system.file("extdata/enrichr.js", package="ezRun", mustWork=TRUE)
invisible(file.copy(from=jsFile, to=basename(jsFile), overwrite=TRUE))
cat(paste0("<SCRIPT language=\"JavaScript\" SRC=\"", basename(jsFile), "\"></SCRIPT>"))
```

## Datasets integration {.tabset}

### Common cell types

Te main goal of dataset integration is to identify shared cell states that are present across different datasets, in case they were collected from different individuals, experimental conditions, technologies, or even species.
The method used here aims to first identify ‘anchors’ between pairs of datasets. These represent pairwise correspondences between individual cells (one in each dataset), that we hypothesize originate from the same biological state. These ‘anchors’ are then used to harmonize the datasets, or transfer information from one dataset to another. The steps we carried out to find common cell states between datasets are explained below: 

1. Data preprocessing and feature selection.
We first per-formed log-normalization of all datasets, using a size factor of 10,000 molecules for each cell. We next standardized expression values for each gene across all cells (z-score transformation), as is standard prior to running dimensional reduction tools. In each dataset, we next aimed to identify a subset of features (e.g., genes) exhibiting high variability across cells, and therefore represent heterogeneous features to prioritize for downstream analysis. Finally, we prioritized features across multiple experiments by examining the number of datasets in which they were independently identified as highly variable. From this ranked list of features, we took the top 2,000 to use as input for downstream analyses.

2. Dimensionality reduction and identification of ‘anchor’ correspondences between datasets.
We initiated this process through dimension reduction, aiming to place datasets in a shared low-dimensional space using canonical correlation analysis (CCA) as an initial dimension reduction. Following dimensional reduction, we identified the K-nearest neighbors (KNNs) for each cell within its paired dataset, based on the L2-normalized CCV. Finally, we identify mutual nearest neighbors (MNN; pairs of cells, with one from each dataset, that are contained within each other’s neighborhoods). We refer to these pairwise correspondences as "anchors".

3. Filtering and scoring anchors.
Incorrect anchor pairs representing cells from distinct biological states can lead to incorrect downstream conclusions. In particular, cells that represent a biological state unique to one dataset should theoretically not participate in anchor pairs, yet in practice, they will do so with low frequency. 

The TSNEs below place similar cells together in low-dimensional space after the integration of the datasets. The first TSNE represents cells according to the sample they belong to, in the second one cells are coloured according to the condition and the third TSNE shows the graph-based common clusters that were found among the datasets.

The presence of visual clusters containing cells from the different datasets provides a comforting illusion that the integration was successful.


```{r tSNE after integration}
plotReducedDim(sce, dimred="TSNE", colour_by="Plate")
plotReducedDim(sce, dimred="TSNE", colour_by="orig.ident")
plotReducedDim(sce, dimred="TSNE", colour_by="ident", text_by="ident", text_size=5) 
```

##### The number of cells in each cluster and sample after the datasets integration is represented on this barplot.
```{r number of cells in each cluster after integration, fig.align='center', fig.width=10, fig.height=6}
cellIdents_perSample = data.frame(colData(sce)[,c("ident", "orig.ident")])
barplot = ggplot(data=cellIdents_perSample, aes(x=cellIdents_perSample[,1], fill=orig.ident)) + geom_bar(stat="Count")
barplot + labs(x="Cluster", y = "Number of cells", fill = "Condition")
```

### Control of the cell clustering

The plots show commonly used QC metrics that allow to explore and filter the cells. 

1. The number of unique genes detected in each cell (nGene). Low-quality cells or empty droplets will often have very few genes. Cell doublets or multiplets may exhibit a very high gene count.
2. The total number of molecules detected within a cell (nUMI). It should correlate strongly with unique genes.
3. The percentage of reads that map to the mitochondrial genome (perc_mito). Low-quality / dying cells often exhibit extensive mitochondrial contamination.

```{r}
showCellCycle = FALSE
if(!is.null(colData(sce)$CellCycle) && !any(is.na(colData(sce)$CellCycle)))
  showCellCycle = TRUE
```

```{r show cell cycle text, eval=showCellCycle, results='asis'}
cat("Additionally, we can visualize the cell cycle of the cells on the TSNE plot. It may be useful to identify cells with similar expression patterns and that are in the same state.")
```
<br/><br/>

```{r control cell clustering}
qc_features = c("detected", "sum", "subsets_Mito_percent")
if(!identical(setdiff(qc_features, colnames(colData(sce))), character(0)))
    qc_features = c("nGene", "nUMI", "perc_mito")

plotReducedDim(sce, dimred="TSNE", colour_by=qc_features[1])
plotReducedDim(sce, dimred="TSNE", colour_by=qc_features[2])
plotReducedDim(sce, dimred="TSNE", colour_by=qc_features[3])

if(showCellCycle)
  plotReducedDim(sce, dimred="TSNE", colour_by="CellCycle")
```


### Batch effects assesment

Large single-cell RNA sequencing projects usually need to generate data across multiple batches due to logistical constraints. This results in systematic differences in the observed expression in cells from different batches, which we refer to as “batch effects”. Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.
Before we actually perform any calculation of cluster markers or differential expression analysis between conditions, it is worth examining whether there is any batch effect in the datasets.

In this case we used the same normalization approach as when finding common cell types in the different datasets. We next found the 2000 features that exhibited the highest cell-to-cell variation in the datasets (i.e, they are highly expressed in some cells, and lowly expressed in others). The gene expression values across all cells were scaled and then PCA was performed on the scaled data. Finally, the clusters were calculated using the graph KNN. 

The TSNEs and the barplot below can help us to visualize if the clusters are balanced and composed by cells from the different batches. If we see clusters that are comprised of cells from a single batch, this indicates that cells of the same type are artificially separated due to technical differences between batches. In this case, we may also consider that there are cell types that are unique to each batch. If a cluster only contains cells from a single batch, one can always debate whether that is caused by a failure of the correction method or if there is truly a batch-specific subpopulation. 

<br/><br/>

```{r tSNE no correction plot, fig.width=8, fig.height=5}
plotReducedDim(sce, dimred =  "TSNE_NOCORRECTED", colour_by = "Plate", label_format = c("TSNE_1","TSNE_2"))
plotReducedDim(sce, dimred =  "TSNE_NOCORRECTED", colour_by = "ident_noCorrected", text_by= "ident_noCorrected", label_format = c("TSNE_1","TSNE_2")) 
```

<br/>

```{r number of cells in each cluster, fig.align='center', fig.width=10, fig.height=6}
cellIdents_perSample = data.frame(colData(sce)[,c("ident_noCorrected", "Plate")])
barplot = ggplot(data=cellIdents_perSample, aes(x=cellIdents_perSample[,1], fill=Plate)) + geom_bar(stat="Count")
barplot + labs(x="Cluster", y = "Number of cells", fill = "Plate")
```

### Top cluster markers

```{r}
posMarkers = read_tsv("pos_markers.tsv")
```


```{r wilcoxon test, eval=!param$batchCorrection, results='asis'}
cat("We found positive markers that defined clusters compared to all other cells via differential expression. The test we used was the Wilcoxon Rank Sum test. Genes with an average, at least 0.25-fold difference (log-scale) between the cells in the tested cluster and the rest of the cells and an adjusted p-value < 0.05 were declared as significant.") 
```

```{r LR test, eval=param$batchCorrection, results='asis'}
cat("We found positive markers that defined clusters compared to all other cells via differential expression using a logistic regression test and including in the model the donor as the batch effect. Genes with an average, at least 0.25-fold difference (log-scale) between the cells in the tested cluster and the rest of the cells and an adjusted p-value < 0.05 were declared as significant.") 
```

<br/>

```{r enrichr markers all, echo=FALSE, eval= doEnrichr(param), results='asis'}
genesPerCluster <- split(posMarkers$gene, posMarkers$cluster)
  jsCall = paste0('enrich({list: "', sapply(genesPerCluster, paste, collapse="\\n"), '", popup: true});')
  enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='", jsCall, 
                         "'>Analyse at Enrichr website</a>")
  enrichrTable <- tibble(Cluster=names(genesPerCluster),
                         "# of posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)
  kable(enrichrTable, format="html", escape=FALSE,
        caption=paste0("GeneSet enrichment: genes with pvalue ", pvalue_allMarkers)) %>%
    kable_styling("striped", full_width = F, position = "left")
```

```{r markers table all, echo=FALSE}
caption ="Expression differences of cluster marker genes"
ezInteractiveTableRmd(posMarkers, digits=4, title=caption)
```

```{r enrichr all2all markers, eval = doEnrichr(param) && param$all2allMarkers, echo=FALSE, results='asis'}
 all2allMarkers = read_tsv("all2allMarkers.tsv")  
 
 for(comparison in names(all2allMarkers)){
    write_tsv(as_tibble(all2allMarkers[[comparison]], rownames="Gene"),
              path=paste0(comparison, ".tsv"))
  }
  genesAllPerCluster <- lapply(all2allMarkers, rownames)
  genesUpPerCluster <- lapply(all2allMarkers, function(x){rownames(x)[x$avg_logFC > 0]})
  genesDownPerCluster <- lapply(all2allMarkers, function(x){rownames(x)[x$avg_logFC < 0]})
  
  jsCall_all = paste0('enrich({list: "', sapply(genesAllPerCluster, paste, collapse="\\n"), '", popup: true});')
  jsCall_up = paste0('enrich({list: "', sapply(genesUpPerCluster, paste, collapse="\\n"), '", popup: true});')
  jsCall_down = paste0('enrich({list: "', sapply(genesDownPerCluster, paste, collapse="\\n"), '", popup: true});')
  
  enrichrCalls_all <- paste0("<a href='javascript:void(0)' onClick='", jsCall_all,
                         "'>Analyse at Enrichr website</a>")
  enrichrCalls_up <- paste0("<a href='javascript:void(0)' onClick='", jsCall_up,
                         "'>Analyse at Enrichr website</a>")
  enrichrCalls_down <- paste0("<a href='javascript:void(0)' onClick='", jsCall_down,
                         "'>Analyse at Enrichr website</a>")
  enrichrTable <- tibble(Comparison=names(all2allMarkers),
                         "# of differentially expressed genes"=lengths(genesAllPerCluster),
                         "Enrichr link: all significant genes"=enrichrCalls_all,
                         "Enrichr link: up-regulated genes"=enrichrCalls_up,
                         "Enrichr link: down-regulated genes"=enrichrCalls_down,
                         "List of differentially expressed genes"=text_spec(paste0(names(all2allMarkers), ".tsv"), link=paste0(names(all2allMarkers), ".tsv")))
  kable(enrichrTable, format="html", escape=FALSE,
        caption=paste0("GeneSet enrichment: genes with pvalue ", pvalue_all2allMarkers)) %>%
    kable_styling("striped", full_width = F, position = "left")
```


### Visualization of cluster markers
#### The strongest `r param$markersToShow` gene markers (highest logFC) for each cluster are represented on the Ridge and the TSNE plots.
<br/>

```{r top cluster markers, fig.width=4, fig.height=3, results = 'asis'}
top_FC <- posMarkers %>% group_by(cluster) %>% top_n(param$markersToShow, avg_logFC)
for(cluster in unique(top_FC$cluster)){
  top_FC_cluster = top_FC[top_FC$cluster == cluster,]
  cat("\n")
  cat(paste0("##### Top "), param$markersToShow, ("markers for cluster "), cluster)
  cat("\n")
   for(i in 1:nrow(top_FC_cluster)){
      print(RidgePlot.sce(sce, feature = as.character(top_FC_cluster$gene[i])))
      print(plotReducedDim(sce, dimred="TSNE", colour_by=top_FC_cluster$gene[i]))
   }
   cat("\n\n")
}
```
### Conserved cell type markers

##### Identify cell type marker genes that are conserved across conditions. Differential gene expression tests are performed for each group and then, the p-values are combined using meta-analysis methods. 

```{r}
conservedMarkers <- read_tsv("conserved_markers.tsv")
```

```{r enrichr conserved markers, eval = doEnrichr(param), results='asis'}
  genesPerCluster <- split(conservedMarkers$gene, conservedMarkers$cluster)
  genesPerCluster <- genesPerCluster[gtools::mixedorder(names(genesPerCluster))]
  jsCall = paste0('enrich({list: "', sapply(genesPerCluster, paste, collapse="\\n"), '", popup: true});')
  enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='", jsCall, 
                         "'>Analyse at Enrichr website</a>")
  enrichrTable <- tibble(Cluster=names(genesPerCluster),
                         "# of conservedMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)
  kable(enrichrTable, format="html", escape=FALSE,
        caption=paste0("GeneSet enrichment analysis: conserved marker genes")) %>%
    kable_styling("striped", full_width = F, position = "left")
```

```{r conserved markers table}
caption ="Conserved cell type markers"
ezInteractiveTableRmd(conservedMarkers, title=caption)
```

### Visualisation of conserved markers
##### The most significant `r param$markersToShow` conserved markers (lowest p-value) for each cluster are represented on the Ridge and the TSNE plots. 
<br/>

```{r top conserved markers, fig.width=4, fig.height=3, results='asis'}
markers.to.plot <- conservedMarkers %>% group_by(cluster) %>% top_n(param$markersToShow, minimump_p_val)
for(cluster in unique(markers.to.plot$cluster)){
  markers.to.plot_cluster = markers.to.plot[markers.to.plot$cluster == cluster,]
  cat("\n")
  cat(paste0("#### Top "), param$markersToShow, ("conserved markers for cluster "), cluster)
  cat("\n")
   for(i in 1:nrow(markers.to.plot_cluster)){
      print(RidgePlot.sce(sce, feature = as.character(markers.to.plot_cluster$gene[i])))
      print(plotReducedDim(sce, dimred="TSNE", colour_by=markers.to.plot_cluster$gene[i]))
   }
  cat("\n\n")
}
```
<br/>

##### The DotPlot can be useful for viewing conserved cell type markers across conditions, showing both the expression level and the percentage of cells in a cluster expressing any given gene. Here we plot 3 strong marker genes for each of the clusters.

```{r dot plot conserved cluster markers, fig.width=14, fig.height=1+length(unique(sce$orig.ident)) * length(unique(sce$orig.ident))*0.2, fig.align='center'}

nrGroups <- length(unique(sce$orig.ident))
markers.to.plot <- conservedMarkers %>% group_by(cluster) %>% top_n(3, minimump_p_val)
plotDots(sce, features = unique(markers.to.plot$gene), group = "orig.ident")
```

### Differential expressed genes


##### After identifying common cell types across conditions, we can look for genes that change in different conditions for cells of the same type. 
<br/><br/>

```{r diff genes table}
diffGenes <- read_tsv("differential_genes.tsv")
caption ="Differential expressed genes per cluster"
ezInteractiveTableRmd(diffGenes, title=caption)
```

### Visualisation of differential expressed genes

##### The 5 most significant differentially expressed genes (lowest p-value) for each cluster are represented on the TSNE and Violin plots. Some genes may be dysregulated in all clusters between conditions.
<br/>

```{r diff genes plots, fig.width=20, fig.height=4, results='asis'}
diffgenes.to.plot <- diffGenes %>% group_by(cluster) %>% top_n(5, p_val_adj)
for(cluster in unique(diffgenes.to.plot$cluster)) {
  diffgenes.to.plot_cluster = diffgenes.to.plot[diffgenes.to.plot$cluster == cluster,]
  cat("\n")
  cat(paste0("#### Top 5 differentially expressed genes for cluster "), cluster)
  cat("\n")
  print(plotExpression(sce, diffgenes.to.plot_cluster$gene, x = "ident", colour_by="orig.ident"))
  cat("\n\n")
}
```

### Interactive explorer

<br>
The iSEE (Interactive SummarizedExperiment Explorer) explorer provides a general visual interface for exploring single cell data. iSEE allows users to simultaneously visualize multiple aspects of a given data set, including experimental data, metadata, and analysis results. Dynamic linking and point selection facilitate the flexible exploration of interactions between different data aspects.
 [Rue-Albrecht K, Marini F, Soneson C, Lun ATL (2018). “iSEE: Interactive SummarizedExperiment Explorer.” F1000Research, 7, 741. doi: 10.12688/f1000research.14966.1.]

The iSEE shiny app can be accessed through this link [iSEE explorer](`r paste0("http://fgcz-shiny.uzh.ch/fgcz_iSEE/?data=",output$getColumn("Report"),"/sce_h5")`)


### Data availability

##### Mean expression of every gene across the cells in each cluster

[geneMeanPerCluster](gene_means_per_cluster.txt)

##### Mean expression of every gene across all the cells

[geneMeans](gene_means.txt)

##### Positive markers of each cluster

[posMarkers](pos_markers.tsv)

```{r, results='asis', eval = param$all2allMarkers}
cat("##### Differential expressed genes from clusters paired comparisons")
cat("\n")
cat("[all2allMarkers](all2allMarkers.tsv)")
```

##### Coordinates of every cell on the TSNE

[tSNE](tSNE_data.tsv)

##### The final Single Cell Experiment Object is [here](sce_h5)

### Parameters
```{r report parameters, echo=FALSE}
param[c("npcs", "resolution", "batchCorrection","chosenClusters")]
```

### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
