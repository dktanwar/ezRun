---
author: "Functional Genomics Center Zurich"
output: 
  html_document:
    self_contained: true
    includes:
      in_header: fgcz_header.html
    css: fgcz.css
editor_options: 
  chunk_output_type: console
---

Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

```{r setup, include=FALSE}
library(SummarizedExperiment)
library(ggplot2)
library(ggridges)
library(cowplot)
library(tibble)
library(dplyr)
library(readr)
library(kableExtra)
library(tidyr)
library(pheatmap)
library(scater)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")


#to test
# library(HDF5Array)
# library(SingleR)
# library(AUCell)
# library(ezRun, lib.loc = "~/myRpackages")
# sce <- loadHDF5SummarizedExperiment("sce_h5")
# param = metadata(sce)$param
# pvalue_allMarkers <- 0.05
```

```{r javascript, results='asis'}
jsFile = system.file("extdata/enrichr.js", package="ezRun", mustWork=TRUE)
invisible(file.copy(from=jsFile, to=basename(jsFile), overwrite=TRUE))
cat(paste0("<SCRIPT language=\"JavaScript\" SRC=\"", basename(jsFile), "\"></SCRIPT>"))
```

```{r}
output <- metadata(sce)$output
```

## Clustering results of merged samples {.tabset}

### Cell clustering without correction

Previous to cluster the cells, we performed a log-normalization of each dataset using a size factor of 10,000 molecules for each cell. In each dataset, we next aimed to identify a subset of genes with high variability across cells (i.e, they are highly expressed in some cells, and lowly expressed in others), and therefore represent heterogeneous features to prioritize for downstream analysis. We next standardized expression values for each gene across all cells in order to avoid the results to be dominated by the signal of a few highly-expressed genes. Next, we performed PCA on the scaled data using the previously determined variable features. Taking as a distance metric the previously identified PCs, the cells clusters were then identified using a graph-based clustering approach where the cells are embedded in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected ‘communities’. 
The TSNEs below place similar cells together in low-dimensional space. The left TSNE represents cells according to the sample they belong to. On the right side, the TSNE shows the graph-based clusters determined before. 
<br/><br/>

```{r tSNE no correction plot, fig.width=8, fig.height=5}
if(param$batchCorrection) {
  reduction_name <- "TSNE_NOCORRECTED"
} else {
  reduction_name <- "TSNE"
}
plotReducedDim(sce, dimred =  reduction_name, colour_by = "Plate", label_format = c("TSNE_1","TSNE_2"))
plotReducedDim(sce, dimred =  reduction_name, colour_by = "ident_noCorrected", text_by= "ident_noCorrected", label_format = c("TSNE_1","TSNE_2")) 
```

<br/><br/>

##### The number of cells in each cluster and sample is represented in this barplot. It helps to visualize if there are existing biases when analyzing multiple datasets together (i.e. some clusters are mainly composed of cells from only one sample).

<br/>

```{r number of cells in each cluster, fig.align='center', fig.width=10, fig.height=6}
if(param$batchCorrection) {
  active_idents <- "ident_noCorrected"
} else {
  active_idents <- "ident"
}
cellIdents_perSample = data.frame(colData(sce)[,c(active_idents, "Plate")])
barplot = ggplot(data=cellIdents_perSample, aes(x=cellIdents_perSample[,1], fill=Plate)) + geom_bar(stat="Count")
barplot + labs(x="Cluster", y = "Number of cells", fill = "Sample")
```


```{r tSNE after integration, results='asis', fig.width=8, fig.height=5, eval = param$batchCorrection}
cat("### Cell clustering after the integration")
cat("\n\n")
cat("In addition to the previous steps that were carried out, we performed an unsupervised identification of \"anchors\" between pairs of datasets.  These anchors represent two cells (with one cell from each dataset), that we predict to originate from a common biological state. We initiate this process through dimensional reduction using canonical correlation analysis (CCA), aiming to place datasets in a shared low-dimensional space. Following dimensional reduction, we identified the K-nearest neighbors (KNNs) for each cell within its paired dataset, based on the L2-normalized CCV. Finally, we identify mutual nearest neighbors (MNN; pairs of cells, with one from each dataset, that are contained within each other’s neighborhoods). We refer to these pairwise correspondences as \"anchors\". Filtering and scoring anchors steps were performed to mitigate the effects of any incorrectly identified pairs of cells.")
cat("\n")
cat("The TSNEs below place similar cells together in low-dimensional space after the batch correction of the datasets. The left TSNE represents cells according to the sample they belong to and on the right side, the TSNE shows the graph-based clusters determined after performing the correction.")
cat("\n\n")
plotReducedDim(sce, dimred="TSNE", colour_by="Plate")
plotReducedDim(sce, dimred="TSNE", colour_by="ident", text_by="ident", text_size=5)
```

```{r number of cells in each cluster after correction, eval = param$batchCorrection, fig.width=10, fig.height=6, fig.align='center', results='asis'}
cat("\n")
cat("##### The number of cells in each cluster and sample after the batch correction is represented on this barplot.") 
cat("\n\n")
cellIdents_perSample = data.frame(colData(sce)[,c("ident", "Plate")])
barplot = ggplot(data=cellIdents_perSample, aes(x=cellIdents_perSample[,1], fill=Plate)) + geom_bar(stat="Count")
barplot + labs(x="Cluster", y = "Number of cells", fill = "Sample")
```

### Control of the cell clustering

The plots show commonly used QC metrics that allow to explore and filter the cells. 

1. The number of unique genes detected in each cell (nGene). Low-quality cells or empty droplets will often have very few genes. Cell doublets or multiplets may exhibit a very high gene count.
2. The total number of molecules detected within a cell (nUMI). It should correlate strongly with unique genes.
3. The percentage of reads that map to the mitochondrial genome (perc_mito). Low-quality / dying cells often exhibit extensive mitochondrial contamination.

```{r}
showCellCycle = FALSE
if(!is.null(colData(sce)$CellCycle) && !any(is.na(colData(sce)$CellCycle)))
  showCellCycle = TRUE
```

```{r show cell cycle text, eval=showCellCycle, results='asis'}
cat("Additionally, we can visualize the cell cycle of the cells on the TSNE plot. It may be useful to identify cells with similar expression patterns and that are in the same state.")
```
<br/><br/>

```{r control cell clustering}
qc_features = c("detected", "sum", "subsets_Mito_percent")
if(!identical(setdiff(qc_features, colnames(colData(sce))), character(0)))
    qc_features = c("nGene", "nUMI", "perc_mito")

plotReducedDim(sce, dimred="TSNE", colour_by=qc_features[1])
plotReducedDim(sce, dimred="TSNE", colour_by=qc_features[2])
plotReducedDim(sce, dimred="TSNE", colour_by=qc_features[3])

if(showCellCycle)
  plotReducedDim(sce, dimred="TSNE", colour_by="CellCycle")
```

### Top cluster markers

We found positive markers that defined clusters compared to all other cells via differential expression. The test we used was the Wilcoxon Rank Sum test. Genes with an average, at least 0.25-fold difference (log-scale) between the cells in the tested cluster and the rest of the cells and an adjusted p-value < 0.05 were declared as significant. 
<br/>

```{r}
posMarkers = read_tsv("pos_markers.tsv")
```


```{r enrichr markers all, echo=FALSE, eval= doEnrichr(param), results='asis'}
  genesPerCluster <- split(posMarkers$gene, posMarkers$cluster)
  jsCall = paste0('enrich({list: "', sapply(genesPerCluster, paste, collapse="\\n"), '", popup: true});')
  enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='", jsCall, 
                         "'>Analyse at Enrichr website</a>")
  enrichrTable <- tibble(Cluster=names(genesPerCluster),
                         "# of posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)
  kable(enrichrTable, format="html", escape=FALSE,
        caption=paste0("GeneSet enrichment: genes with pvalue ", pvalue_allMarkers)) %>%
    kable_styling("striped", full_width = F, position = "left")
```

```{r markers table all, echo=FALSE}
caption ="Expression differences of cluster marker genes"
ezInteractiveTableRmd(posMarkers, digits=4, title=caption)
```

```{r enrichr all2all markers, eval = doEnrichr(param) && param$all2allMarkers, echo=FALSE, results='asis'}
 all2allMarkers = read_tsv("all2allMarkers.tsv")  
 
 for(comparison in names(all2allMarkers)){
    write_tsv(as_tibble(all2allMarkers[[comparison]], rownames="Gene"),
              path=paste0(comparison, ".tsv"))
  }
  genesAllPerCluster <- lapply(all2allMarkers, rownames)
  genesUpPerCluster <- lapply(all2allMarkers, function(x){rownames(x)[x$avg_logFC > 0]})
  genesDownPerCluster <- lapply(all2allMarkers, function(x){rownames(x)[x$avg_logFC < 0]})
  
  jsCall_all = paste0('enrich({list: "', sapply(genesAllPerCluster, paste, collapse="\\n"), '", popup: true});')
  jsCall_up = paste0('enrich({list: "', sapply(genesUpPerCluster, paste, collapse="\\n"), '", popup: true});')
  jsCall_down = paste0('enrich({list: "', sapply(genesDownPerCluster, paste, collapse="\\n"), '", popup: true});')
  
  enrichrCalls_all <- paste0("<a href='javascript:void(0)' onClick='", jsCall_all,
                         "'>Analyse at Enrichr website</a>")
  enrichrCalls_up <- paste0("<a href='javascript:void(0)' onClick='", jsCall_up,
                         "'>Analyse at Enrichr website</a>")
  enrichrCalls_down <- paste0("<a href='javascript:void(0)' onClick='", jsCall_down,
                         "'>Analyse at Enrichr website</a>")
  enrichrTable <- tibble(Comparison=names(all2allMarkers),
                         "# of differentially expressed genes"=lengths(genesAllPerCluster),
                         "Enrichr link: all significant genes"=enrichrCalls_all,
                         "Enrichr link: up-regulated genes"=enrichrCalls_up,
                         "Enrichr link: down-regulated genes"=enrichrCalls_down,
                         "List of differentially expressed genes"=text_spec(paste0(names(all2allMarkers), ".tsv"), link=paste0(names(all2allMarkers), ".tsv")))
  kable(enrichrTable, format="html", escape=FALSE,
        caption=paste0("GeneSet enrichment: genes with pvalue ", pvalue_all2allMarkers)) %>%
    kable_styling("striped", full_width = F, position = "left")
```

### Visualization of cluster markers
#### The strongest `r param$markersToShow` gene markers (highest logFC) for each cluster are represented on the Ridge and the TSNE plots.
<br/>

```{r top cluster markers, fig.width=4, fig.height=3, results = 'asis'}
top_FC <- posMarkers %>% group_by(cluster) %>% top_n(param$markersToShow, avg_logFC)
for(cluster in unique(top_FC$cluster)){
  top_FC_cluster = top_FC[top_FC$cluster == cluster,]
  cat("\n")
  cat(paste0("##### Top "), param$markersToShow, ("markers for cluster "), cluster)
  cat("\n")
   for(i in 1:nrow(top_FC_cluster)){
      print(RidgePlot.sce(sce, feature = as.character(top_FC_cluster$gene[i])))
      print(plotReducedDim(sce, dimred="TSNE", colour_by=top_FC_cluster$gene[i]))
   }
   cat("\n\n")
}
```

### Cells annotation

The most challenging task in scRNA-seq data analysis is the interpretation of the results. Once we have obtained a set of clusters we want to determine what biological state is represented by each of them.
We do this using sets of marker genes that are highly expressed in each cell. This does not require matching of individual cells to the expression values of the reference dataset, which is faster and more convenient when only the identities of the markers are available. In this case, we use sets of gene markers for individual cell types taken from the CellMarkers database which contains an accurate resource of cell markers for various cell types in tissues of human and mouse (Zhang X., Lan Y., Xu J., Quan F., Zhao E., Deng C., et al. (2019). CellMarker: a manually curated resource of cell markers in human and mouse. Nucleic Acids Res. 47, D721–d728. 10.1093/nar/gky900). 
We use the AUCell package (Aibar et al. (2017) SCENIC: single-cell regulatory network inference and clustering. Nature Methods. doi: 10.1038/nmeth.4463) to identify marker sets that are highly expressed in each cell. AUCell uses the “Area Under the Curve” (AUC) to calculate whether a critical subset of the input gene set is enriched within the expressed genes for each cell. The AUC estimates the proportion of genes in the gene-set that are highly expressed in each cell. Cells expressing many genes from the gene-set will have higher AUC values than cells expressing fewer. Finally, it assigns cell type identity to each cell in the test dataset by taking the marker set with the top AUC as the label for that cell.

```{r AUC assigments, eval= (param$species != "other"), results='asis'}
cells_AUC <- metadata(sce)$cells_AUC
cells_assignment <- AUCell_exploreThresholds(cells_AUC, plotHist=FALSE, assign=TRUE) 
cellsAssigned <- lapply(cells_assignment, function(x) x$assignment)
assignmentTable <- reshape2::melt(cellsAssigned, value.name="cell")
colnames(assignmentTable)[2] <- "geneSet"
cat("We can explore the cell assignment results using different plots. Below, we show a heatmap that represents the number of cells (in log scale) from each cluster that were assigned to the different cell types. After calculating an AUC score for each cell and cell type, we assign cell type identity by taking the cell type with the top AUC as the label for that cell. Some cell types may be missing because no cells obtained their top AUC score for it.")
cat("\n\n")
```
<br/>

```{r assigments heatmap, eval= (param$species != "other"), results='asis',fig.align='center', fig.width=10, fig.height=6}
tras_cells_AUC <- t(assay(cells_AUC))
full.labels <- colnames(tras_cells_AUC)[max.col(tras_cells_AUC)]
tab <- table(full.labels, colData(sce)[,"seurat_clusters"])
print(pheatmap(log10(tab+10), color=viridis::viridis(100), silent=TRUE))
```

```{r tsne and AUC hist res, eval= (param$species != "other"), results='asis'}
cat("The plots below show for every cell type:\n")
cat('\n')
cat("1) The distribution of the AUC values in the cells. The ideal situation will be a bi-modal distribution, in which most cells in the dataset have a low “AUC” compared to a population of cells with a higher value.  The size of the gene-set will also affect the results. With smaller gene-genes (fewer genes), it is more likely to get cells with AUC = 0. While this is the case of the “perfect markers” it is also easier to get it by chance with small datasets. The vertical bars correspond to several thresholds that could be used to consider a gene-set ‘active’. The thickest vertical line indicates the threshold selected by default: the highest value to reduce the false positives.\n")
cat('\n')
cat("2) The t-SNE can be colored based on the AUC scores. To highlight the cluster of cells that are more likely of the cell type according to the signatures, we split the cells into cells that passed the assignment threshold (colored in blue), and cells that didn’t (colored in gray).\n")
cat('\n')
cat("3) The last TSNE represents the AUC scores values. The darker a cell is the higher AUC score it obtained, i.e. the cell is more enriched in that cell type.")
cat('\n')
cellsTsne <- reducedDims(sce)$TSNE
filtered_cells_AUC <- cells_AUC[,colSums(assay(cells_AUC))>0]
```

```{r tsne and AUC hist, eval= (param$species != "other"), fig.height=5, fig.width=5}
AUCell_plotTSNE(tSNE=cellsTsne, exprMat=counts(sce), cellsAUC=cells_AUC)
```

### Interactive explorer

<br>
The iSEE (Interactive SummarizedExperiment Explorer) explorer provides a general visual interface for exploring single cell data. iSEE allows users to simultaneously visualize multiple aspects of a given data set, including experimental data, metadata, and analysis results. Dynamic linking and point selection facilitate the flexible exploration of interactions between different data aspects.
 [Rue-Albrecht K, Marini F, Soneson C, Lun ATL (2018). “iSEE: Interactive SummarizedExperiment Explorer.” F1000Research, 7, 741. doi: 10.12688/f1000research.14966.1.]

The iSEE shiny app can be accessed through this link [iSEE explorer](`r paste0("http://fgcz-shiny.uzh.ch/fgcz_iSEE/?data=",output$getColumn("Report"),"/sce_h5")`)


### Data availability

##### Mean expression of every gene across the cells in each cluster

[geneMeanPerCluster](gene_means_per_cluster.txt)

##### Mean expression of every gene across all the cells

[geneMeans](gene_means.txt)

##### Positive markers of each cluster

[posMarkers](pos_markers.tsv)

```{r, results='asis', eval = param$all2allMarkers}
cat("##### Differential expressed genes from clusters paired comparisons")
cat("\n")
cat("[all2allMarkers](all2allMarkers.tsv)")
```

##### Coordinates of every cell on the TSNE

[tSNE](tSNE_data.tsv)

##### The final Single Cell Experiment Object is [here](sce_h5)

### Parameters
```{r report parameters, echo=FALSE}
param[c("npcs", "resolution", "batchCorrection","chosenClusters")]
```


### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
